
/*
 * This file was generated by Hermes Parser Generator on Tue May  9 17:05:56 2017
 * 
 * Hermes command: hermes generate ../grammar.hgr --language=javascript --name=wdl --nodejs --header --directory .
 * Run from: . (relative to this file)
 * Hermes version: hermes-parser 2.0rc6
 * 
 * !!! DO NOT CHANGE THIS FILE DIRECTLY !!!
 * 
 * If you wish to change something in this file, either change the grammar and
 * re-generate this file, or change the templates in Hermes and regenerate.
 * See the Hermes repository: http://github.com/scottfrazer/hermes
 */
if (!String.prototype.format) {
    String.prototype.format = function() {
        var args = arguments;
        return this.replace(/{(\d+)}/g, function(match, number) {
            return typeof args[number] != 'undefined' ? args[number]: match;
        });
    };
}
String.prototype.lstrip = function() {
    return this.replace(/^\s*/g, "");
}
function parse_tree_string(parsetree, indent, b64_source) {
    return _parse_tree_string(parsetree, indent, b64_source, 0);
}
function _parse_tree_string(parsetree, indent, b64_source, indent_level) {
    if (typeof(indent) != 'number' || indent <= 0) {
        indent = undefined
    }
    var indent_str = typeof(indent) !== 'undefined' ? Array(indent * indent_level + 1).join(' ') : ''
    if (parsetree instanceof ParseTree) {
        var children = []
        for (var i in parsetree.children) {
            children.push(_parse_tree_string(parsetree.children[i], indent, b64_source, indent_level + 1))
        }
        if (typeof(indent) == 'undefined' || children.length == 0) {
            return '{0}({1}: {2})'.format(indent_str, parsetree.nonterminal.to_string(), children.join(', '))
        } else {
            return '{0}({1}:\n{2}\n{3})'.format(
                indent_str,
                parsetree.nonterminal.to_string(),
                children.join(',\n'),
                indent_str
            )
        }
    } else if (parsetree instanceof Terminal) {
        return indent_str + parsetree.to_string(b64_source)
    }
}
function ast_string(ast, indent, b64_source) {
    return _ast_string(ast, indent, b64_source, 0);
}
function _ast_string(ast, indent, b64_source, indent_level) {
    if (typeof(indent) != 'number' || indent <= 0) {
        indent = undefined
    }
    var indent_str = typeof(indent) !== 'undefined' ? Array(indent * indent_level + 1).join(' ') : ''
    var next_indent_str = typeof(indent) !== 'undefined' ? Array(indent * (indent_level+1) + 1).join(' ') : ''
    if (ast instanceof Ast) {
        var children = {}
        for (var key in ast.attributes) {
            children[key] = _ast_string(ast.attributes[key], indent, b64_source, indent_level + 1)
        }
        if (typeof(indent) == 'undefined') {
            var strs = []
            for (var key in children) {
                strs.push('{0}={1}'.format(key, children[key]))
            }
            return '({0}: {1})'.format(
                ast.name,
                strs.join(', ')
            )
        } else {
            var strs = []
            for (var key in children) {
                strs.push('{0}{1}={2}'.format(next_indent_str, key, children[key]))
            }
            return '({0}:\n{1}\n{2})'.format(
                ast.name,
                strs.join(',\n'),
                indent_str
            )
        }
    } else if (ast instanceof AstList) {
        var children = []
        for (var key in ast.list) {
            children.push(_ast_string(ast.list[key], indent, b64_source, indent_level + 1))
        }
        if (typeof(indent) == 'undefined' || children.length == 0) {
            return '[{0}]'.format(children.join(', '))
        } else {
            var strs = []
            for (var index in children) {
                strs.push('{0}{1}'.format(next_indent_str, children[index]))
            }
            return '[\n{0}\n{1}]'.format(
                strs.join(',\n'),
                indent_str
            )
        }
    } else if (ast instanceof Terminal) {
        return ast.to_string(b64_source)
    } else {
        return (ast == null) ? 'None' : ast.to_string()
    }
}
function Terminal(id, str, source_string, resource, line, col) {
    this.id = id;
    this.str = str;
    this.source_string = source_string;
    this.resource = resource;
    this.line = line;
    this.col = col;
    this.to_ast = function() {
        return this;
    };
    this.to_string = function(b64_source) {
        return '<{0}:{1}:{2} {3} "{4}">'.format(
            this.resource,
            this.line,
            this.col,
            this.str,
            b64_source ? Base64.encode(this.source_string) : this.source_string
        )
    };
}
function NonTerminal(id, str) {
    this.id = id;
    this.str = str;
    this.to_string = function() {
        return this.str;
    };
}
function AstTransformSubstitution(idx) {
    this.idx = idx;
    this.to_string = function() {
        return '$' + this.idx;
    };
}
function AstTransformNodeCreator(name, parameters) {
    this.name = name;
    this.parameters = parameters;
    this.to_string = function() {
        var arr = [];
        for ( key in this.parameters ) {
            arr.push('{0}=${1}'.format(key, this.parameters[key]));
        }
        return '{0} ( {1} )'.format(this.name, arr.join(', '));
    };
}
function AstList(list) {
    this.list = list
    this.push = function(element) {
        this.list.push(element);
    };
    this.to_ast = function() {
        var arr = [];
        for (item in this.list) {
            arr.push(item.to_ast());
        }
        return arr;
    };
}
function ParseTree(nonterminal) {
    this.children = [];
    this.nonterminal = nonterminal;
    this.astTransform = null;
    this.isExpr = false;
    this.isNud = false;
    this.isPrefix = false;
    this.isInfix = false;
    this.nudMorphemeCount = 0;
    this.isExprNud = false;
    this.listSeparator = null;
    this.list = false;
    this.add = function(tree) {
        this.children.push(tree);
    }
    this.to_ast = function() {
        if (this.list == true) {
            if (this.children.length == 0) {
                return new AstList([]);
            }
            var end = this.children.length - 1;
            var list = [];
            for (var i = 0; i < this.children.length; i++) {
                if (this.children[i] instanceof Terminal && this.children[i].id == this.listSeparator)
                    continue;
                list.push(this.children[i].to_ast());
            }
            return new AstList(list);
        }
        else if (this.isExpr == true) {
            if (this.astTransform instanceof AstTransformSubstitution) {
                return this.children[this.astTransform.idx].to_ast();
            }
            else if (this.astTransform instanceof AstTransformNodeCreator) {
                var parameters = {}
                for (name in this.astTransform.parameters) {
                    var idx = this.astTransform.parameters[name];
                    var child = null;
                    if (idx == '$') {
                        child = this.children[0];
                    } else if (this.children[0] instanceof ParseTree && this.children[0].isNud && !this.children[0].isPrefix && !this.isExprNud && !this.isInfix) {
                        if (idx < this.children[0].nudMorphemeCount) {
                            child = this.children[0].children[idx]
                        } else {
                            index = idx - this.children[0].nudMorphemeCount + 1
                            child = this.children[index]
                        }
                    } else if (this.children.length == 1 && !(this.children[0] instanceof ParseTree) && !(this.children[0] instanceof Array)) {
                        return this.children[0];
                    } else {
                        child = this.children[idx];
                    }
                    parameters[name] = child.to_ast()
                }
                return new Ast(this.astTransform.name, parameters);
            }
        }
        else {
            if (this.astTransform instanceof AstTransformSubstitution) {
                return this.children[this.astTransform.idx].to_ast()
            } else if (this.astTransform instanceof AstTransformNodeCreator) {
                var parameters = {};
                for (name in this.astTransform.parameters) {
                    parameters[name] = this.children[this.astTransform.parameters[name]].to_ast();
                }
                return new Ast(this.astTransform.name, parameters);
                return x;
            } else if (this.children.length) {
                return this.children[0].to_ast();
            } else {
                return null;
            }
        }
    }
    this.to_string = function() {
        var children = []
        for (i in this.children) {
            var child = this.children[i];
            if (child instanceof Array) {
                var stringify = child.map(function(x) {return x.to_string()});
                children.push('[' + stringify.join(', ') + ']');
            } else {
                children.push(child.to_string());
            }
        }
        return '(' + this.nonterminal.to_string() + ': ' + children.join(', ') + ')'
    }
}
function Ast(name, attributes) {
    this.name = name;
    this.attributes = attributes;
    this.to_string = function() {
        var arr = [];
        for (var key in this.attributes) {
            var value = this.attributes[key];
            if (value instanceof Array) {
                var stringify = value.map(function(x) {return x.to_string()});
                value = '[{0}]'.format(stringify.join(', '));
            } else {
                value = value.to_string();
            }
            arr.push('{0}={1}'.format(key.to_string(), value))
        }
        return '({0}: {1})'.format(this.name, arr.join(', '));
    }
}
function SyntaxError(message) {
    this.message = message;
    this.to_string = function() {
        return this.message;
    }
}
function TokenStream(list) {
    this.list = list;
    this.index = 0;
    this.advance = function() {
        this.index += 1;
        return this.current();
    }
    this.last = function() {
        return this.list[this.list.length - 1];
    }
    this.current = function() {
        if (this.index < this.list.length) {
            return this.list[this.index];
        } else {
            return null;
        }
    }
}
function DefaultSyntaxErrorFormatter() {
    this.unexpected_eof = function(nonterminal, expected_terminals, nonterminal_rules) {
        return "Error: unexpected end of file";
    }
    this.excess_tokens = function(nonterminal, terminal) {
        return "Finished parsing without consuming all tokens.";
    }
    this.unexpected_symbol = function(nonterminal, actual_terminal, expected_terminals, rule) {
        return "Unexpected symbol (line {0}, col {1}) when parsing parse_{2}.  Expected {3}, got {4}.".format(
          actual_terminal.line,
          actual_terminal.col,
          nonterminal,
          expected_terminals.join(', '),
          actual_terminal.to_string(true)
        );
    }
    this.no_more_tokens = function(nonterminal, expected_terminal, last_terminal) {
        return "No more tokens.  Expecting " + expected_terminal;
    }
    this.invalid_terminal = function(nonterminal, invalid_terminal) {
        return "Invalid symbol ID: {0} ({1})".format(invalid_terminal.id, invalid_terminal.string);
    }
    this.missing_list_items = function(method, required, found, last) {
        return "List for "+method+" requires "+required+" items but only "+found+" were found.";
    }
    this.missing_terminator = function(method, terminator, last) {
        return "List for "+method+" is missing a terminator";
    }
}
function ParserContext(tokens, error_formatter) {
    this.tokens = tokens;
    this.error_formatter = error_formatter;
    this.nonterminal_string = null;
    this.rule_string = null;
}
function MultiRegExp(par) {
    var regex;
    if (par.source !== undefined){
        regex = par;
    } else {
        var exp = par;
        var opts = "";
        if (par.substring(0, 1) == "/") {
            var l = par.lastIndexOf("/");
            opts = par.substring(l + 1, par.length);
            exp = par.substring(1, l);
        }
        regex = new RegExp(exp, opts);
    }
    var expandSource = function (braces, indexer) {
        ret = '';
        for (var i = 0; i < braces.length; i++) {
            if (braces[i].type == 'raw') {
                ret += '(' + braces[i].text + ')';
                indexer.next();
            } else if (braces[i].type == 'brace' && braces[i].containsCapture) {
                ret += braces[i].pre + expandSource(braces[i].children, indexer) + braces[i].post;
            } else if (braces[i].type == 'brace' && !braces[i].isCapture) {
                ret += '(' + braces[i].text.substring(braces[i].pre.length, braces[i].text.length - braces[i].post.length) + ')';
                indexer.next();
            } else if (braces[i].type == 'brace') {
                ret += braces[i].text;
                indexer.next(true);
            } else {
                ret += braces[i].text;
            }
        }
        return ret;
    }
    var captureScan = function(braces, parent) {
        var containsCapture = false;
        for (var i = 0; i < braces.length; i++) {
            captureScan(braces[i].children, braces[i]);
            braces[i].isCapture = braces[i].text.indexOf('(?:') != 0;
            if (braces[i].isCapture) {
                containsCapture = true;
            }
            if (braces[i].isCapture && braces[i].containsCapture) {
                throw "nested captures not permitted, use (?:...) where capture is not intended";
            }
        }
        if (parent) {
            parent.containsCapture = containsCapture;
        }
    }
    var fillGaps = function(braces, text) {
        var pre = /^\((\?.)?/.exec(text);
        pre = pre == null ? '' : pre[0];
        var post = /\)$/.exec(text);
        post = post == null ? '' : post[0];
        var i = 0;
        if (braces.length > 0) {
            fillGaps(braces[0].children, braces[0].text);
        }
        if (braces.length > 0 && braces[0].pos > pre.length) {
            braces.splice(0, 0, {type: 'raw', pos: pre.length, length: braces[0].pos, text: text.substring(pre.length, braces[0].pos)});
            i++;
        }
        for(i++ ;i < braces.length; i++) {
            fillGaps(braces[i].children, braces[i].text);
            if (braces[i].pos > braces[i-1].pos + braces[i-1].length) {
                braces.splice(i, 0, {type:'raw', pos: braces[i-1].pos + braces[i-1].length,
                                     length: braces[i].pos - (braces[i-1].pos + braces[i-1].length),
                                     text: text.substring(braces[i-1].pos + braces[i-1].length,
                                                          braces[i].pos)});
                i++;
            }
        }
        if (braces.length == 0)
        {
            braces.push({type:'raw', pos: pre.length, length: text.length - post.length - pre.length, text: text.substring(pre.length, text.length - post.length)});
        } else if (braces[braces.length - 1].pos + braces[braces.length - 1].length < text.length - post.length) { 
            var pos = braces[braces.length - 1].pos + braces[braces.length - 1].length;
            var txt = text.substring(pos, text.length - post.length);
            braces.push({type:'raw', pos: pos, length: txt.length, text: txt});
        }
    }
    var GetBraces = function(text) {
        var ret = [];
        var shift = 0;
        do {
            var brace = GetBrace(text);
            if (brace == null) {
                break;
            } else {
                text = text.substring(brace.pos + brace.length);
                var del = brace.pos + brace.length;
                brace.pos += shift;
                shift += del;
                ret.push(brace);
            }
        } while (brace != null);
        return ret;
    }
    var GetBrace = function(text) {
        var ret = {pos: -1, length: 0, text: '', children: [], type: 'brace'};
        var openExp = /^(?:\\.|[^\)\\\(])*\(\?./;
        var pre = 3;
        var post = 1;
        var m = openExp.exec(text);
        if (m == null) {
            m = /^(?:\\.|[^\)\\\(])*\(/.exec(text);
            pre = 1;
        }
        if (m != null) {
            ret.pos = m[0].length - pre;
            ret.children = GetBraces(text.substring(m[0].length));
            for (var i = 0; i < ret.children.length; i++) {
                ret.children[i].pos += pre;
            }
            var closeExp = /^(?:\\.|[^\\\(\)])*\)/;
            var closeExpAlt = /^(?:\\.|[^\\\(\)])*\)\?/;
            var from = ret.children.length <= 0 ? ret.pos + pre : 
                ret.children[ret.children.length-1].pos + 
                    ret.children[ret.children.length-1].length + 
                    m[0].length - pre;
            var m2 = closeExp.exec(text.substring(from));
            var m3 = closeExpAlt.exec(text.substring(from));
            if (m3 !== null && m3.length - 1 <= m2.length) {
                m2 = m3;
                post = 2;
            }
            if (m2 == null) {
                return null;
            } else {
                ret.length = m2[0].length + from - ret.pos;
                ret.text = text.substring(ret.pos, ret.pos + ret.length);
            }
        }
        if (ret.text == '()' || /^\(\?.\)$/.test(ret.text)) {
            throw 'empty braces not permitted';
        }
        if (ret.pos != -1) {
            ret.pre = ret.text.substring(0, pre);
            ret.post = ret.text.substring(ret.text.length - post, ret.text.length);
        }
        return ret.pos == -1 ? null : ret;
    }
    var fixOrs = function (braces_W_raw) {
        var orFind = /^(\\.|[^\\|])*\|/;
        for (var i = 0; i < braces_W_raw.length; i++) {
            if (braces_W_raw[i].type == 'raw') {
                var fullText = braces_W_raw[i].text;
                var m = orFind.exec(fullText);
                if (m != null) {
                    var or = { type: 'or', pos: m[0].length - 1 + braces_W_raw[i].pos, length: 1, text: '|' };
                    var raw = { type: 'raw', pos: m[0].length + braces_W_raw[i].pos,
                        length: fullText.length - m[0].length,
                        text: fullText.substring(m[0].length, fullText.length)
                    };
                    braces_W_raw[i].text = fullText.substring(0, m[0].length - 1);
                    braces_W_raw[i].length = braces_W_raw[i].text.length;
                    braces_W_raw.splice(i + 1, 0, or, raw);
                    i += 1;
                }
            } else if (braces_W_raw[i].type == 'brace') {
                fixOrs(braces_W_raw[i].children, braces_W_raw[i].text);
            }
        }
    }
    var source = regex.source;
    var braces = GetBraces(source);
    captureScan(braces);
    fillGaps(braces, source);
    fixOrs(braces);
    var indexer = {i: 1, next:
                       function (realPoint) {
                           if (realPoint) {
                               this.points.push(this.i);
                           }
                           return this.i++;
                       }, points: []};
    source = expandSource(braces, indexer);
    this.dataPoints = indexer.points;
    var options = (regex.ignoreCase ? "i" : "") + (regex.global ? "g" : "") + (regex.multiline ? "m" : "");
    this.regex = new RegExp(source, options);
    this.exec = function (text) {
        var m = this.regex.exec(text);
        if (m == null) {
            return {};
        }
        var ret = {};
        var ch = 0;
        for (var i = 1; i < m.length; i++) {
            if (m[i] !== null && m[i] !== undefined) {
                var pos = this.dataPoints.indexOf(i);
                if (pos != -1) {
                    ret[pos] = {index: ch, text: m[i]};
                }
                ch += m[i].length;
            }
        }
        for (var i = 0; i < this.dataPoints.length; i++) {
            if (ret[i] === undefined) {
                ret[i] = null;
            }
        }
        return ret;
    }
}
var Base64 = {
    // private property
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    // public method for encoding
    encode : function (input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        input = Base64._utf8_encode(input);
        while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }
            output = output +
            Base64._keyStr.charAt(enc1) + Base64._keyStr.charAt(enc2) +
            Base64._keyStr.charAt(enc3) + Base64._keyStr.charAt(enc4);
        }
        return output;
    },
    // public method for decoding
    decode : function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
            enc1 = Base64._keyStr.indexOf(input.charAt(i++));
            enc2 = Base64._keyStr.indexOf(input.charAt(i++));
            enc3 = Base64._keyStr.indexOf(input.charAt(i++));
            enc4 = Base64._keyStr.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
                output = output + String.fromCharCode(chr3);
            }
        }
        output = Base64._utf8_decode(output);
        return output;
    },
    // private method for UTF-8 encoding
    _utf8_encode : function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";
        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }
        return utftext;
    },
    // private method for UTF-8 decoding
    _utf8_decode : function (utftext) {
        var string = "";
        var i = 0;
        var c = c1 = c2 = 0;
        while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
        }
        return string;
    }
}
// Section: Parser
var terminals = {
    0: 'not',
    1: 'fqn',
    2: 'call',
    3: 'else',
    4: 'dash',
    5: 'dot',
    6: 'raw_cmd_start',
    7: 'lbrace',
    8: 'type',
    9: 'lt',
    10: 'e',
    11: 'integer',
    12: 'float',
    13: 'rbrace',
    14: 'double_pipe',
    15: 'double_ampersand',
    16: 'object',
    17: 'rparen',
    18: 'not_equal',
    19: 'type_e',
    20: 'scatter',
    21: 'rsquare',
    22: 'double_equal',
    23: 'cmd_param_end',
    24: 'while',
    25: 'plus',
    26: 'comma',
    27: 'gteq',
    28: 'slash',
    29: 'percent',
    30: 'lteq',
    31: 'workflow',
    32: 'then',
    33: 'output',
    34: 'as',
    35: 'raw_command',
    36: 'in',
    37: 'cmd_attr_hint',
    38: 'cmd_param_start',
    39: 'lsquare',
    40: 'asterisk',
    41: 'if',
    42: 'gt',
    43: 'boolean',
    44: 'identifier',
    45: 'parameter_meta',
    46: 'string',
    47: 'lparen',
    48: 'equal',
    49: 'import',
    50: 'raw_cmd_end',
    51: 'input',
    52: 'qmark',
    53: 'colon',
    54: 'cmd_part',
    55: 'runtime',
    56: 'task',
    57: 'meta',
    'not': 0,
    'fqn': 1,
    'call': 2,
    'else': 3,
    'dash': 4,
    'dot': 5,
    'raw_cmd_start': 6,
    'lbrace': 7,
    'type': 8,
    'lt': 9,
    'e': 10,
    'integer': 11,
    'float': 12,
    'rbrace': 13,
    'double_pipe': 14,
    'double_ampersand': 15,
    'object': 16,
    'rparen': 17,
    'not_equal': 18,
    'type_e': 19,
    'scatter': 20,
    'rsquare': 21,
    'double_equal': 22,
    'cmd_param_end': 23,
    'while': 24,
    'plus': 25,
    'comma': 26,
    'gteq': 27,
    'slash': 28,
    'percent': 29,
    'lteq': 30,
    'workflow': 31,
    'then': 32,
    'output': 33,
    'as': 34,
    'raw_command': 35,
    'in': 36,
    'cmd_attr_hint': 37,
    'cmd_param_start': 38,
    'lsquare': 39,
    'asterisk': 40,
    'if': 41,
    'gt': 42,
    'boolean': 43,
    'identifier': 44,
    'parameter_meta': 45,
    'string': 46,
    'lparen': 47,
    'equal': 48,
    'import': 49,
    'raw_cmd_end': 50,
    'input': 51,
    'qmark': 52,
    'colon': 53,
    'cmd_part': 54,
    'runtime': 55,
    'task': 56,
    'meta': 57,
}
// table[nonterminal][terminal] = rule
var table = [
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, 63, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 59, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, 2, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, 67, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, 7, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, 35, -1, -1, -1, -1, -1, 35, -1, -1, -1, -1, 35, -1, -1, -1, -1, -1, 35, 35, -1, -1, -1, 35, -1, -1, -1, -1, -1, -1, 35, -1, 35, -1, 35, -1, -1, -1, -1, -1, 35, -1, -1, -1, 35, -1, -1, 34, -1, -1, 35, -1, -1, -1, 35, 35, 35],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, 52, -1, -1, -1, -1, 51, 52, -1, -1, -1, -1, 52, -1, -1, -1, -1, -1, 52, 52, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, 52, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, 68, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 70],
    [-1, -1, 50, -1, -1, -1, -1, 50, 50, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, 50, 50, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, 50, 49, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50],
    [-1, -1, -1, -1, -1, -1, -1, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, 41, -1, -1, -1, -1, -1, 42, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 42, 45, -1, -1, -1, 43, -1, -1, -1, -1, -1, -1, -1, -1, 46, -1, -1, -1, -1, -1, -1, -1, 44, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 28, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 71, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, 66, -1, -1, -1, 65, -1, -1, 66, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1],
    [38, -1, -1, -1, 38, -1, -1, 38, -1, -1, 38, 38, 38, -1, -1, -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, 38, -1, 38, 38, -1, 38, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, 17],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
]
var nonterminal_first = {
    58: [-1, 8, 19],
    59: [-1, 8, 19],
    60: [1, 8, 19],
    61: [44],
    62: [57],
    63: [-1, 44],
    64: [48],
    65: [41],
    66: [8, -1, 31, 56, 19],
    67: [34],
    68: [-1, 56, 31, 8, 49, 19],
    69: [51],
    70: [8, 19],
    71: [1],
    72: [-1, 34],
    73: [33],
    74: [-1, 48],
    75: [34],
    76: [0, 4, 7, 11, 10, 39, 41, 12, 43, 44, 16, 46, 25, 47, -1],
    77: [8, 56, 31, 19],
    78: [-1, 37],
    79: [-1, 44],
    80: [20, 2, 24, 8, -1, 41, 45, 33, 57, 19],
    81: [-1, 7],
    82: [-1, 44],
    83: [5],
    84: [56],
    85: [8, 19],
    86: [38],
    87: [44],
    88: [-1, 1, 8, 19],
    89: [20],
    90: [7],
    91: [-1, 49],
    92: [2],
    93: [57],
    94: [-1, 34],
    95: [7],
    96: [20, 2, 24, 8, 41, 45, 33, 57, 19],
    97: [55],
    98: [-1, 38, 54],
    99: [24],
    100: [-1, 5],
    101: [44],
    102: [45],
    103: [31],
    104: [49],
    105: [0, 16, 4, 25, 47, 7, 11, 10, 39, 41, 12, 43, 44, 46],
    106: [57, 35, 33, 55, 45],
    107: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    108: [8, 19],
    109: [-1, 35, 55, 45, 33, 57],
    110: [33],
    111: [45],
    112: [-1, 8, 19],
    113: [37],
    114: [38, 54],
    115: [-1, 51],
    116: [0, 4, 7, 11, 10, 39, 41, 12, 43, 16, 44, 46, 25, 47, -1],
    117: [35],
    118: [8, 19],
}
var nonterminal_follow = {
    58: [21],
    59: [35, 55, 51, 45, 33, 57],
    60: [1, 13, 8, 19],
    61: [26, 13],
    62: [35, 55, 13, 45, 33, 57],
    63: [13],
    64: [2, 35, 8, 41, 13, 45, 33, 19, 20, 24, -1, 51, 31, 55, 56, 57],
    65: [20, 2, 24, 8, 41, 13, 45, 33, 57, 19],
    66: [-1],
    67: [20, 2, 24, 8, 7, 41, 13, 45, 33, 57, 19],
    68: [-1],
    69: [51, 13],
    70: [1, 13, 8, 19],
    71: [1, 13, 8, 19],
    72: [56, 31, -1, 8, 49, 19],
    73: [20, 2, 24, 8, 41, 13, 45, 33, 57, 19],
    74: [2, 35, 8, 41, 13, 45, 33, 19, 20, 24, -1, 51, 31, 55, 56, 57],
    75: [56, 31, -1, 8, 49, 19],
    76: [13],
    77: [8, -1, 31, 56, 19],
    78: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    79: [13],
    80: [13],
    81: [20, 2, 24, 8, 41, 13, 45, 33, 57, 19],
    82: [51, 13],
    83: [1, 13, 8, 19],
    84: [8, -1, 31, 56, 19],
    85: [2, 35, 8, 41, 13, 45, 19, 20, 56, 24, -1, 51, 31, 55, 33, 57],
    86: [38, 50, 54],
    87: [26, 51, 13],
    88: [13],
    89: [20, 2, 24, 8, 41, 13, 45, 33, 57, 19],
    90: [20, 2, 24, 8, 41, 13, 45, 33, 57, 19],
    91: [-1, 8, 56, 31, 19],
    92: [20, 2, 24, 8, 41, 13, 45, 33, 57, 19],
    93: [20, 2, 24, 8, 41, 13, 45, 33, 57, 19],
    94: [20, 2, 24, 8, 7, 41, 13, 45, 33, 57, 19],
    95: [20, 2, 35, 24, 8, 41, 55, 13, 45, 33, 57, 19],
    96: [20, 2, 24, 8, 41, 13, 45, 33, 57, 19],
    97: [35, 55, 13, 45, 33, 57],
    98: [50],
    99: [20, 2, 24, 8, 41, 13, 45, 33, 57, 19],
    100: [1, 13, 8, 19],
    101: [44, 13],
    102: [20, 2, 24, 8, 41, 13, 45, 33, 57, 19],
    103: [8, -1, 31, 56, 19],
    104: [56, 31, -1, 8, 49, 19],
    105: [26, 13],
    106: [35, 55, 13, 45, 33, 57],
    107: [0, 1, 3, 2, 4, 8, 9, 7, 11, 10, 12, 13, 15, 14, 16, 18, 17, 19, 20, 21, 22, 23, 25, 24, 26, 27, 28, 29, 30, 31, 32, 33, 35, 37, 39, 40, 42, 41, 43, 44, 45, 46, 47, 51, -1, 53, 55, 56, 57],
    108: [8, 13, 19],
    109: [13],
    110: [35, 55, 13, 45, 33, 57],
    111: [35, 55, 13, 45, 33, 57],
    112: [13],
    113: [0, 4, 37, 7, 11, 10, 39, 41, 12, 43, 16, 44, 46, 25, 47],
    114: [38, 50, 54],
    115: [13],
    116: [21, 17],
    117: [35, 55, 13, 45, 33, 57],
    118: [44, 21, 26],
}
var rule_first = {
    0: [-1, 49],
    1: [-1, 8, 56, 31, 19],
    2: [8, 49, -1, 31, 56, 19],
    3: [31],
    4: [56],
    5: [8, 19],
    6: [34],
    7: [-1],
    8: [49],
    9: [34],
    10: [-1, 8, 19],
    11: [35, -1, 55, 45, 33, 57],
    12: [56],
    13: [35],
    14: [33],
    15: [55],
    16: [45],
    17: [57],
    18: [-1, 38, 54],
    19: [35],
    20: [54],
    21: [38],
    22: [37, -1],
    23: [38],
    24: [37],
    25: [-1, 8, 19],
    26: [33],
    27: [8, 19],
    28: [55],
    29: [45],
    30: [57],
    31: [-1, 44],
    32: [7],
    33: [44],
    34: [48],
    35: [-1],
    36: [8, 19],
    37: [48],
    38: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    39: [20, 2, 24, 8, -1, 41, 45, 33, 57, 19],
    40: [31],
    41: [2],
    42: [8, 19],
    43: [24],
    44: [41],
    45: [20],
    46: [33],
    47: [45],
    48: [57],
    49: [34],
    50: [-1],
    51: [7],
    52: [-1],
    53: [2],
    54: [-1, 51],
    55: [7],
    56: [-1, 44],
    57: [51],
    58: [44],
    59: [34],
    60: [-1, 1, 8, 19],
    61: [33],
    62: [8, 19],
    63: [1],
    64: [8, 19],
    65: [5],
    66: [-1],
    67: [1],
    68: [5],
    69: [45],
    70: [57],
    71: [24],
    72: [41],
    73: [20],
    74: [44],
    75: [-1, 8, 19],
    76: [8],
    77: [8],
    78: [8],
    79: [8],
    80: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    81: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    82: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    83: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    84: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    85: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    86: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    87: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    88: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    89: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    90: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    91: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    92: [0, 4, 25, 44, 47, 7, 11, 10, 39, 41, 12, 43, 16, 46],
    93: [0],
    94: [25],
    95: [4],
    96: [0, 4, 25, 44, 47, 7, 11, 10, 39, -1, 41, 12, 43, 16, 46],
    97: [44],
    98: [44],
    99: [44],
    100: [-1, 44],
    101: [16],
    102: [39],
    103: [0, 16, 4, 25, 47, 7, 11, 10, 39, -1, 41, 12, 43, 44, 46],
    104: [7],
    105: [47],
    106: [41],
    107: [46],
    108: [44],
    109: [43],
    110: [11],
    111: [12],
}
var nonterminal_rules = {
    58: [
        "$_gen17 = list($type_e, :comma)",
    ],
    59: [
        "$_gen3 = list($declaration)",
    ],
    60: [
        "$wf_output = $wf_output_declaration_syntax",
        "$wf_output = $wf_output_wildcard_syntax",
    ],
    61: [
        "$object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )",
    ],
    62: [
        "$meta = :meta $map -> Meta( map=$1 )",
    ],
    63: [
        "$_gen19 = list($object_kv, :comma)",
    ],
    64: [
        "$setter = :equal $e -> $1",
    ],
    65: [
        "$if_stmt = :if :lparen $e :rparen :lbrace $_gen10 :rbrace -> If( expression=$2, body=$5 )",
    ],
    66: [
        "$_gen1 = list($workflow_or_task_or_decl)",
    ],
    67: [
        "$alias = :as :identifier -> $1",
    ],
    68: [
        "$document = $_gen0 $_gen1 -> Namespace( imports=$0, body=$1 )",
    ],
    69: [
        "$call_input = :input :colon $_gen14 -> Inputs( map=$2 )",
    ],
    70: [
        "$wf_output_declaration_syntax = $type_e :identifier :equal $e -> WorkflowOutputDeclaration( type=$0, name=$1, expression=$3 )",
    ],
    71: [
        "$wf_output_wildcard_syntax = :fqn $_gen16 -> WorkflowOutputWildcard( fqn=$0, wildcard=$1 )",
    ],
    72: [
        "$_gen2 = $import_namespace",
        "$_gen2 = :_empty",
    ],
    73: [
        "$wf_outputs = :output :lbrace $_gen15 :rbrace -> WorkflowOutputs( outputs=$2 )",
    ],
    74: [
        "$_gen9 = $setter",
        "$_gen9 = :_empty",
    ],
    75: [
        "$import_namespace = :as :identifier -> $1",
    ],
    76: [
        "$_gen20 = list($map_kv, :comma)",
    ],
    77: [
        "$workflow_or_task_or_decl = $workflow",
        "$workflow_or_task_or_decl = $task",
        "$workflow_or_task_or_decl = $declaration",
    ],
    78: [
        "$_gen6 = list($cmd_param_kv)",
    ],
    79: [
        "$_gen8 = list($kv)",
    ],
    80: [
        "$_gen10 = list($wf_body_element)",
    ],
    81: [
        "$_gen12 = $call_body",
        "$_gen12 = :_empty",
    ],
    82: [
        "$_gen14 = list($mapping, :comma)",
    ],
    83: [
        "$wf_output_wildcard = :dot :asterisk -> $1",
    ],
    84: [
        "$task = :task :identifier :lbrace $_gen3 $_gen4 :rbrace -> Task( name=$1, declarations=$3, sections=$4 )",
    ],
    85: [
        "$declaration = $type_e :identifier $_gen9 -> Declaration( type=$0, name=$1, expression=$2 )",
    ],
    86: [
        "$cmd_param = :cmd_param_start $_gen6 $e :cmd_param_end -> CommandParameter( attributes=$1, expr=$2 )",
    ],
    87: [
        "$mapping = :identifier :equal $e -> IOMapping( key=$0, value=$2 )",
    ],
    88: [
        "$_gen15 = list($wf_output)",
    ],
    89: [
        "$scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen10 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )",
    ],
    90: [
        "$call_body = :lbrace $_gen3 $_gen13 :rbrace -> CallBody( declarations=$1, io=$2 )",
    ],
    91: [
        "$_gen0 = list($import)",
    ],
    92: [
        "$call = :call :fqn $_gen11 $_gen12 -> Call( task=$1, alias=$2, body=$3 )",
    ],
    93: [
        "$wf_meta = :meta $map -> Meta( map=$1 )",
    ],
    94: [
        "$_gen11 = $alias",
        "$_gen11 = :_empty",
    ],
    95: [
        "$map = :lbrace $_gen8 :rbrace -> $1",
    ],
    96: [
        "$wf_body_element = $call",
        "$wf_body_element = $declaration",
        "$wf_body_element = $while_loop",
        "$wf_body_element = $if_stmt",
        "$wf_body_element = $scatter",
        "$wf_body_element = $wf_outputs",
        "$wf_body_element = $wf_parameter_meta",
        "$wf_body_element = $wf_meta",
    ],
    97: [
        "$runtime = :runtime $map -> Runtime( map=$1 )",
    ],
    98: [
        "$_gen5 = list($command_part)",
    ],
    99: [
        "$while_loop = :while :lparen $e :rparen :lbrace $_gen10 :rbrace -> WhileLoop( expression=$2, body=$5 )",
    ],
    100: [
        "$_gen16 = $wf_output_wildcard",
        "$_gen16 = :_empty",
    ],
    101: [
        "$kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )",
    ],
    102: [
        "$wf_parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )",
    ],
    103: [
        "$workflow = :workflow :identifier :lbrace $_gen10 :rbrace -> Workflow( name=$1, body=$3 )",
    ],
    104: [
        "$import = :import :string $_gen2 -> Import( uri=$1, namespace=$2 )",
    ],
    105: [
        "$map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )",
    ],
    106: [
        "$sections = $command",
        "$sections = $outputs",
        "$sections = $runtime",
        "$sections = $parameter_meta",
        "$sections = $meta",
    ],
    107: [
        "$e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )",
        "$e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )",
        "$e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )",
        "$e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )",
        "$e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )",
        "$e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )",
        "$e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )",
        "$e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )",
        "$e = $e :plus $e -> Add( lhs=$0, rhs=$2 )",
        "$e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )",
        "$e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )",
        "$e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )",
        "$e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )",
        "$e = :not $e -> LogicalNot( expression=$1 )",
        "$e = :plus $e -> UnaryPlus( expression=$1 )",
        "$e = :dash $e -> UnaryNegation( expression=$1 )",
        "$e = :identifier <=> :lparen $_gen18 :rparen -> FunctionCall( name=$0, params=$2 )",
        "$e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )",
        "$e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )",
        "$e = :object :lbrace $_gen19 :rbrace -> ObjectLiteral( map=$2 )",
        "$e = :lsquare $_gen18 :rsquare -> ArrayLiteral( values=$1 )",
        "$e = :lbrace $_gen20 :rbrace -> MapLiteral( map=$1 )",
        "$e = :lparen $_gen18 :rparen -> TupleLiteral( values=$1 )",
        "$e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )",
        "$e = :string",
        "$e = :identifier",
        "$e = :boolean",
        "$e = :integer",
        "$e = :float",
    ],
    108: [
        "$output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )",
    ],
    109: [
        "$_gen4 = list($sections)",
    ],
    110: [
        "$outputs = :output :lbrace $_gen7 :rbrace -> Outputs( attributes=$2 )",
    ],
    111: [
        "$parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )",
    ],
    112: [
        "$_gen7 = list($output_kv)",
    ],
    113: [
        "$cmd_param_kv = :cmd_attr_hint :identifier :equal $e -> CommandParameterAttr( key=$1, value=$3 )",
    ],
    114: [
        "$command_part = :cmd_part",
        "$command_part = $cmd_param",
    ],
    115: [
        "$_gen13 = list($call_input)",
    ],
    116: [
        "$_gen18 = list($e, :comma)",
    ],
    117: [
        "$command = :raw_command :raw_cmd_start $_gen5 :raw_cmd_end -> RawCommand( parts=$2 )",
    ],
    118: [
        "$type_e = :type <=> :lsquare $_gen17 :rsquare -> Type( name=$0, subtype=$2 )",
        "$type_e = :type <=> :qmark -> OptionalType( innerType=$0 )",
        "$type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )",
        "$type_e = :type",
    ],
}
var rules = {
    0: "$_gen0 = list($import)",
    1: "$_gen1 = list($workflow_or_task_or_decl)",
    2: "$document = $_gen0 $_gen1 -> Namespace( imports=$0, body=$1 )",
    3: "$workflow_or_task_or_decl = $workflow",
    4: "$workflow_or_task_or_decl = $task",
    5: "$workflow_or_task_or_decl = $declaration",
    6: "$_gen2 = $import_namespace",
    7: "$_gen2 = :_empty",
    8: "$import = :import :string $_gen2 -> Import( uri=$1, namespace=$2 )",
    9: "$import_namespace = :as :identifier -> $1",
    10: "$_gen3 = list($declaration)",
    11: "$_gen4 = list($sections)",
    12: "$task = :task :identifier :lbrace $_gen3 $_gen4 :rbrace -> Task( name=$1, declarations=$3, sections=$4 )",
    13: "$sections = $command",
    14: "$sections = $outputs",
    15: "$sections = $runtime",
    16: "$sections = $parameter_meta",
    17: "$sections = $meta",
    18: "$_gen5 = list($command_part)",
    19: "$command = :raw_command :raw_cmd_start $_gen5 :raw_cmd_end -> RawCommand( parts=$2 )",
    20: "$command_part = :cmd_part",
    21: "$command_part = $cmd_param",
    22: "$_gen6 = list($cmd_param_kv)",
    23: "$cmd_param = :cmd_param_start $_gen6 $e :cmd_param_end -> CommandParameter( attributes=$1, expr=$2 )",
    24: "$cmd_param_kv = :cmd_attr_hint :identifier :equal $e -> CommandParameterAttr( key=$1, value=$3 )",
    25: "$_gen7 = list($output_kv)",
    26: "$outputs = :output :lbrace $_gen7 :rbrace -> Outputs( attributes=$2 )",
    27: "$output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )",
    28: "$runtime = :runtime $map -> Runtime( map=$1 )",
    29: "$parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )",
    30: "$meta = :meta $map -> Meta( map=$1 )",
    31: "$_gen8 = list($kv)",
    32: "$map = :lbrace $_gen8 :rbrace -> $1",
    33: "$kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )",
    34: "$_gen9 = $setter",
    35: "$_gen9 = :_empty",
    36: "$declaration = $type_e :identifier $_gen9 -> Declaration( type=$0, name=$1, expression=$2 )",
    37: "$setter = :equal $e -> $1",
    38: "$map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )",
    39: "$_gen10 = list($wf_body_element)",
    40: "$workflow = :workflow :identifier :lbrace $_gen10 :rbrace -> Workflow( name=$1, body=$3 )",
    41: "$wf_body_element = $call",
    42: "$wf_body_element = $declaration",
    43: "$wf_body_element = $while_loop",
    44: "$wf_body_element = $if_stmt",
    45: "$wf_body_element = $scatter",
    46: "$wf_body_element = $wf_outputs",
    47: "$wf_body_element = $wf_parameter_meta",
    48: "$wf_body_element = $wf_meta",
    49: "$_gen11 = $alias",
    50: "$_gen11 = :_empty",
    51: "$_gen12 = $call_body",
    52: "$_gen12 = :_empty",
    53: "$call = :call :fqn $_gen11 $_gen12 -> Call( task=$1, alias=$2, body=$3 )",
    54: "$_gen13 = list($call_input)",
    55: "$call_body = :lbrace $_gen3 $_gen13 :rbrace -> CallBody( declarations=$1, io=$2 )",
    56: "$_gen14 = list($mapping, :comma)",
    57: "$call_input = :input :colon $_gen14 -> Inputs( map=$2 )",
    58: "$mapping = :identifier :equal $e -> IOMapping( key=$0, value=$2 )",
    59: "$alias = :as :identifier -> $1",
    60: "$_gen15 = list($wf_output)",
    61: "$wf_outputs = :output :lbrace $_gen15 :rbrace -> WorkflowOutputs( outputs=$2 )",
    62: "$wf_output = $wf_output_declaration_syntax",
    63: "$wf_output = $wf_output_wildcard_syntax",
    64: "$wf_output_declaration_syntax = $type_e :identifier :equal $e -> WorkflowOutputDeclaration( type=$0, name=$1, expression=$3 )",
    65: "$_gen16 = $wf_output_wildcard",
    66: "$_gen16 = :_empty",
    67: "$wf_output_wildcard_syntax = :fqn $_gen16 -> WorkflowOutputWildcard( fqn=$0, wildcard=$1 )",
    68: "$wf_output_wildcard = :dot :asterisk -> $1",
    69: "$wf_parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )",
    70: "$wf_meta = :meta $map -> Meta( map=$1 )",
    71: "$while_loop = :while :lparen $e :rparen :lbrace $_gen10 :rbrace -> WhileLoop( expression=$2, body=$5 )",
    72: "$if_stmt = :if :lparen $e :rparen :lbrace $_gen10 :rbrace -> If( expression=$2, body=$5 )",
    73: "$scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen10 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )",
    74: "$object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )",
    75: "$_gen17 = list($type_e, :comma)",
    76: "$type_e = :type <=> :lsquare $_gen17 :rsquare -> Type( name=$0, subtype=$2 )",
    77: "$type_e = :type <=> :qmark -> OptionalType( innerType=$0 )",
    78: "$type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )",
    79: "$type_e = :type",
    80: "$e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )",
    81: "$e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )",
    82: "$e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )",
    83: "$e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )",
    84: "$e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )",
    85: "$e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )",
    86: "$e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )",
    87: "$e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )",
    88: "$e = $e :plus $e -> Add( lhs=$0, rhs=$2 )",
    89: "$e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )",
    90: "$e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )",
    91: "$e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )",
    92: "$e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )",
    93: "$e = :not $e -> LogicalNot( expression=$1 )",
    94: "$e = :plus $e -> UnaryPlus( expression=$1 )",
    95: "$e = :dash $e -> UnaryNegation( expression=$1 )",
    96: "$_gen18 = list($e, :comma)",
    97: "$e = :identifier <=> :lparen $_gen18 :rparen -> FunctionCall( name=$0, params=$2 )",
    98: "$e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )",
    99: "$e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )",
    100: "$_gen19 = list($object_kv, :comma)",
    101: "$e = :object :lbrace $_gen19 :rbrace -> ObjectLiteral( map=$2 )",
    102: "$e = :lsquare $_gen18 :rsquare -> ArrayLiteral( values=$1 )",
    103: "$_gen20 = list($map_kv, :comma)",
    104: "$e = :lbrace $_gen20 :rbrace -> MapLiteral( map=$1 )",
    105: "$e = :lparen $_gen18 :rparen -> TupleLiteral( values=$1 )",
    106: "$e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )",
    107: "$e = :string",
    108: "$e = :identifier",
    109: "$e = :boolean",
    110: "$e = :integer",
    111: "$e = :float",
}
function is_terminal(id){
    return 0 <= id && id <= 57;
}
function parse(tokens, error_formatter, start) {
    if (error_formatter === undefined) {
        error_formatter = new DefaultSyntaxErrorFormatter();
    }
    var ctx = new ParserContext(tokens, error_formatter);
    var tree = parse_document(ctx);
    if (tokens.current() != null) {
        throw new SyntaxError('Finished parsing without consuming all tokens.');
    }
    return tree;
}
function expect(ctx, terminal_id) {
    var current = ctx.tokens.current();
    if (current == null) {
        throw new SyntaxError(ctx.error_formatter.no_more_tokens(ctx.nonterminal, terminals[terminal_id], ctx.tokens.last()));
    }
    if (current.id != terminal_id) {
        throw new SyntaxError(ctx.error_formatter.unexpected_symbol(ctx.nonterminal, current, [terminals[terminal_id]], ctx.rule));
    }
    var next = ctx.tokens.advance();
    if (next && !is_terminal(next.id)) {
        throw new SyntaxError(ctx.error_formatter.invalid_terminal(ctx.nonterminal, next));
    }
    return current;
}
// START definitions for expression parser `e`
var infix_binding_power_e = {
    14: 4000, // $e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )
    15: 5000, // $e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )
    22: 6000, // $e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )
    18: 6000, // $e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )
    9: 7000, // $e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )
    30: 7000, // $e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )
    42: 7000, // $e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )
    27: 7000, // $e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )
    25: 8000, // $e = $e :plus $e -> Add( lhs=$0, rhs=$2 )
    4: 8000, // $e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )
    40: 9000, // $e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )
    28: 9000, // $e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )
    29: 9000, // $e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )
    47: 11000, // $e = :identifier <=> :lparen list($e, :comma) :rparen -> FunctionCall( name=$0, params=$2 )
    39: 12000, // $e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
    5: 13000, // $e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )
}
var prefix_binding_power_e = {
    0: 10000, // $e = :not $e -> LogicalNot( expression=$1 )
    25: 10000, // $e = :plus $e -> UnaryPlus( expression=$1 )
    4: 10000, // $e = :dash $e -> UnaryNegation( expression=$1 )
}
function get_infix_binding_power_e(terminal_id) {
    if (terminal_id in infix_binding_power_e) {
        return infix_binding_power_e[terminal_id];
    } else {
        return 0;
    }
}
function get_prefix_binding_power_e(terminal_id) {
    if (terminal_id in prefix_binding_power_e) {
        return prefix_binding_power_e[terminal_id];
    } else {
        return 0;
    }
}
function parse_e(ctx) {
    return parse_e_internal(ctx, 0);
}
function parse_e_internal(ctx, rbp) {
    left = nud_e(ctx);
    if (left instanceof ParseTree) {
        left.isExpr = true;
        left.isNud = true;
    }
    while (ctx.tokens.current() && rbp < get_infix_binding_power_e(ctx.tokens.current().id)) {
        left = led_e(left, ctx);
    }
    if (left) {
        left.isExpr = true;
    }
    return left;
}
function nud_e(ctx) {
    var tree = new ParseTree(new NonTerminal(107, 'e'));
    var current = ctx.tokens.current();
    ctx.nonterminal = "e";
    if (!current) {
        return tree;
    }
    else if (rule_first[93].indexOf(current.id) != -1) {
        // $e = :not $e -> LogicalNot( expression=$1 )
        ctx.rule = rules[93];
        ast_parameters = {
            'expression': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('LogicalNot', ast_parameters);
        tree.nudMorphemeCount = 2;
        tree.add(expect(ctx, 0));
        tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(0)));
        tree.isPrefix = true;
    }
    else if (rule_first[94].indexOf(current.id) != -1) {
        // $e = :plus $e -> UnaryPlus( expression=$1 )
        ctx.rule = rules[94];
        ast_parameters = {
            'expression': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('UnaryPlus', ast_parameters);
        tree.nudMorphemeCount = 2;
        tree.add(expect(ctx, 25));
        tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(25)));
        tree.isPrefix = true;
    }
    else if (rule_first[95].indexOf(current.id) != -1) {
        // $e = :dash $e -> UnaryNegation( expression=$1 )
        ctx.rule = rules[95];
        ast_parameters = {
            'expression': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('UnaryNegation', ast_parameters);
        tree.nudMorphemeCount = 2;
        tree.add(expect(ctx, 4));
        tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(4)));
        tree.isPrefix = true;
    }
    else if (rule_first[97].indexOf(current.id) != -1) {
        // $e = :identifier <=> :lparen $_gen18 :rparen -> FunctionCall( name=$0, params=$2 )
        ctx.rule = rules[97];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 44));
    }
    else if (rule_first[98].indexOf(current.id) != -1) {
        // $e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
        ctx.rule = rules[98];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 44));
    }
    else if (rule_first[99].indexOf(current.id) != -1) {
        // $e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )
        ctx.rule = rules[99];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 44));
    }
    else if (rule_first[101].indexOf(current.id) != -1) {
        // $e = :object :lbrace $_gen19 :rbrace -> ObjectLiteral( map=$2 )
        ctx.rule = rules[101];
        ast_parameters = {
            'map': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('ObjectLiteral', ast_parameters);
        tree.nudMorphemeCount = 4;
        tree.add(expect(ctx, 16));
        tree.add(expect(ctx, 7));
        tree.add(parse__gen19(ctx));
        tree.add(expect(ctx, 13));
    }
    else if (rule_first[102].indexOf(current.id) != -1) {
        // $e = :lsquare $_gen18 :rsquare -> ArrayLiteral( values=$1 )
        ctx.rule = rules[102];
        ast_parameters = {
            'values': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('ArrayLiteral', ast_parameters);
        tree.nudMorphemeCount = 3;
        tree.add(expect(ctx, 39));
        tree.add(parse__gen18(ctx));
        tree.add(expect(ctx, 21));
    }
    else if (rule_first[104].indexOf(current.id) != -1) {
        // $e = :lbrace $_gen20 :rbrace -> MapLiteral( map=$1 )
        ctx.rule = rules[104];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('MapLiteral', ast_parameters);
        tree.nudMorphemeCount = 3;
        tree.add(expect(ctx, 7));
        tree.add(parse__gen20(ctx));
        tree.add(expect(ctx, 13));
    }
    else if (rule_first[105].indexOf(current.id) != -1) {
        // $e = :lparen $_gen18 :rparen -> TupleLiteral( values=$1 )
        ctx.rule = rules[105];
        ast_parameters = {
            'values': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('TupleLiteral', ast_parameters);
        tree.nudMorphemeCount = 3;
        tree.add(expect(ctx, 47));
        tree.add(parse__gen18(ctx));
        tree.add(expect(ctx, 17));
    }
    else if (rule_first[106].indexOf(current.id) != -1) {
        // $e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )
        ctx.rule = rules[106];
        ast_parameters = {
            'cond': 1,
            'iftrue': 3,
            'iffalse': 5,
        }
        tree.astTransform = new AstTransformNodeCreator('TernaryIf', ast_parameters);
        tree.nudMorphemeCount = 6;
        tree.add(expect(ctx, 41));
        tree.add(parse_e(ctx));
        tree.add(expect(ctx, 32));
        tree.add(parse_e(ctx));
        tree.add(expect(ctx, 3));
        tree.add(parse_e(ctx));
    }
    else if (rule_first[107].indexOf(current.id) != -1) {
        // $e = :string
        ctx.rule = rules[107];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 46));
    }
    else if (rule_first[108].indexOf(current.id) != -1) {
        // $e = :identifier
        ctx.rule = rules[108];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 44));
    }
    else if (rule_first[109].indexOf(current.id) != -1) {
        // $e = :boolean
        ctx.rule = rules[109];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 43));
    }
    else if (rule_first[110].indexOf(current.id) != -1) {
        // $e = :integer
        ctx.rule = rules[110];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 11));
    }
    else if (rule_first[111].indexOf(current.id) != -1) {
        // $e = :float
        ctx.rule = rules[111];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 12));
    }
    return tree;
}
function led_e(left, ctx) {
    var tree = new ParseTree(new NonTerminal(107, 'e'))
    var current = ctx.tokens.current()
    ctx.nonterminal = "e";
    if (current.id == 14) { // :double_pipe
        // $e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )
        ctx.rule = rules[80];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('LogicalOr', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 14)); // :double_pipe
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(14) - modifier));
    }
    if (current.id == 15) { // :double_ampersand
        // $e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )
        ctx.rule = rules[81];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('LogicalAnd', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 15)); // :double_ampersand
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(15) - modifier));
    }
    if (current.id == 22) { // :double_equal
        // $e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )
        ctx.rule = rules[82];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Equals', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 22)); // :double_equal
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(22) - modifier));
    }
    if (current.id == 18) { // :not_equal
        // $e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )
        ctx.rule = rules[83];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('NotEquals', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 18)); // :not_equal
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(18) - modifier));
    }
    if (current.id == 9) { // :lt
        // $e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )
        ctx.rule = rules[84];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('LessThan', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 9)); // :lt
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(9) - modifier));
    }
    if (current.id == 30) { // :lteq
        // $e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )
        ctx.rule = rules[85];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('LessThanOrEqual', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 30)); // :lteq
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(30) - modifier));
    }
    if (current.id == 42) { // :gt
        // $e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )
        ctx.rule = rules[86];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('GreaterThan', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 42)); // :gt
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(42) - modifier));
    }
    if (current.id == 27) { // :gteq
        // $e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )
        ctx.rule = rules[87];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('GreaterThanOrEqual', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 27)); // :gteq
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(27) - modifier));
    }
    if (current.id == 25) { // :plus
        // $e = $e :plus $e -> Add( lhs=$0, rhs=$2 )
        ctx.rule = rules[88];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Add', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 25)); // :plus
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(25) - modifier));
    }
    if (current.id == 4) { // :dash
        // $e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )
        ctx.rule = rules[89];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Subtract', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 4)); // :dash
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(4) - modifier));
    }
    if (current.id == 40) { // :asterisk
        // $e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )
        ctx.rule = rules[90];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Multiply', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 40)); // :asterisk
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(40) - modifier));
    }
    if (current.id == 28) { // :slash
        // $e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )
        ctx.rule = rules[91];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Divide', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 28)); // :slash
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(28) - modifier));
    }
    if (current.id == 29) { // :percent
        // $e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )
        ctx.rule = rules[92];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Remainder', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 29)); // :percent
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(29) - modifier));
    }
    if (current.id == 47) { // :lparen
        // $e = :identifier <=> :lparen $_gen18 :rparen -> FunctionCall( name=$0, params=$2 )
        ctx.rule = rules[97];
        ast_parameters = {
            'name': 0,
            'params': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('FunctionCall', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 47)); // :lparen
        tree.add(parse__gen18(ctx));
        tree.add(expect(ctx, 17)); // :rparen
    }
    if (current.id == 39) { // :lsquare
        // $e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
        ctx.rule = rules[98];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('ArrayOrMapLookup', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 39)); // :lsquare
        modifier = 0;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(39) - modifier));
        tree.add(expect(ctx, 21)); // :rsquare
    }
    if (current.id == 5) { // :dot
        // $e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )
        ctx.rule = rules[99];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('MemberAccess', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 5)); // :dot
        tree.add(expect(ctx, 44)); // :identifier
    }
    return tree;
}
// END definitions for expression parser `e`
// START definitions for expression parser `type_e`
var infix_binding_power_type_e = {
    39: 1000, // $type_e = :type <=> :lsquare list($type_e, :comma) :rsquare -> Type( name=$0, subtype=$2 )
    52: 2000, // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
    25: 3000, // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
}
var prefix_binding_power_type_e = {
}
function get_infix_binding_power_type_e(terminal_id) {
    if (terminal_id in infix_binding_power_type_e) {
        return infix_binding_power_type_e[terminal_id];
    } else {
        return 0;
    }
}
function get_prefix_binding_power_type_e(terminal_id) {
    if (terminal_id in prefix_binding_power_type_e) {
        return prefix_binding_power_type_e[terminal_id];
    } else {
        return 0;
    }
}
function parse_type_e(ctx) {
    return parse_type_e_internal(ctx, 0);
}
function parse_type_e_internal(ctx, rbp) {
    left = nud_type_e(ctx);
    if (left instanceof ParseTree) {
        left.isExpr = true;
        left.isNud = true;
    }
    while (ctx.tokens.current() && rbp < get_infix_binding_power_type_e(ctx.tokens.current().id)) {
        left = led_type_e(left, ctx);
    }
    if (left) {
        left.isExpr = true;
    }
    return left;
}
function nud_type_e(ctx) {
    var tree = new ParseTree(new NonTerminal(118, 'type_e'));
    var current = ctx.tokens.current();
    ctx.nonterminal = "type_e";
    if (!current) {
        return tree;
    }
    if (rule_first[76].indexOf(current.id) != -1) {
        // $type_e = :type <=> :lsquare $_gen17 :rsquare -> Type( name=$0, subtype=$2 )
        ctx.rule = rules[76];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 8));
    }
    else if (rule_first[77].indexOf(current.id) != -1) {
        // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
        ctx.rule = rules[77];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 8));
    }
    else if (rule_first[78].indexOf(current.id) != -1) {
        // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
        ctx.rule = rules[78];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 8));
    }
    else if (rule_first[79].indexOf(current.id) != -1) {
        // $type_e = :type
        ctx.rule = rules[79];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 8));
    }
    return tree;
}
function led_type_e(left, ctx) {
    var tree = new ParseTree(new NonTerminal(118, 'type_e'))
    var current = ctx.tokens.current()
    ctx.nonterminal = "type_e";
    if (current.id == 39) { // :lsquare
        // $type_e = :type <=> :lsquare $_gen17 :rsquare -> Type( name=$0, subtype=$2 )
        ctx.rule = rules[76];
        ast_parameters = {
            'name': 0,
            'subtype': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Type', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 39)); // :lsquare
        tree.add(parse__gen17(ctx));
        tree.add(expect(ctx, 21)); // :rsquare
    }
    if (current.id == 52) { // :qmark
        // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
        ctx.rule = rules[77];
        ast_parameters = {
            'innerType': 0,
        }
        tree.astTransform = new AstTransformNodeCreator('OptionalType', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 52)); // :qmark
    }
    if (current.id == 25) { // :plus
        // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
        ctx.rule = rules[78];
        ast_parameters = {
            'innerType': 0,
        }
        tree.astTransform = new AstTransformNodeCreator('NonEmptyType', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 25)); // :plus
    }
    return tree;
}
// END definitions for expression parser `type_e`
function parse__gen0(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[33][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(91, '_gen0'));
    ctx.nonterminal = "_gen0";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[91].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[91].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[91].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_import(ctx));
        ctx.nonterminal = "_gen0";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen1(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[8][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(66, '_gen1'));
    ctx.nonterminal = "_gen1";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[66].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[66].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[66].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_workflow_or_task_or_decl(ctx));
        ctx.nonterminal = "_gen1";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen10(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[22][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(80, '_gen10'));
    ctx.nonterminal = "_gen10";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[80].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[80].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[80].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_wf_body_element(ctx));
        ctx.nonterminal = "_gen10";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen13(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[57][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(115, '_gen13'));
    ctx.nonterminal = "_gen13";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[115].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[115].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[115].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_call_input(ctx));
        ctx.nonterminal = "_gen13";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen14(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[24][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(82, '_gen14'));
    ctx.nonterminal = "_gen14";
    tree.list = true;
    tree.listSeparator = 26;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[82].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[82].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[82].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_mapping(ctx));
        ctx.nonterminal = "_gen14";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 26) {
          tree.add(expect(ctx, 26));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen14",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen15(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[30][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(88, '_gen15'));
    ctx.nonterminal = "_gen15";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[88].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[88].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[88].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_wf_output(ctx));
        ctx.nonterminal = "_gen15";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen17(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[0][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(58, '_gen17'));
    ctx.nonterminal = "_gen17";
    tree.list = true;
    tree.listSeparator = 26;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[58].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[58].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[58].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_type_e(ctx));
        ctx.nonterminal = "_gen17";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 26) {
          tree.add(expect(ctx, 26));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen17",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen18(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[58][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(116, '_gen18'));
    ctx.nonterminal = "_gen18";
    tree.list = true;
    tree.listSeparator = 26;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[116].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[116].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[116].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_e(ctx));
        ctx.nonterminal = "_gen18";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 26) {
          tree.add(expect(ctx, 26));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen18",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen19(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[5][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(63, '_gen19'));
    ctx.nonterminal = "_gen19";
    tree.list = true;
    tree.listSeparator = 26;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[63].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[63].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[63].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_object_kv(ctx));
        ctx.nonterminal = "_gen19";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 26) {
          tree.add(expect(ctx, 26));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen19",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen20(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[18][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(76, '_gen20'));
    ctx.nonterminal = "_gen20";
    tree.list = true;
    tree.listSeparator = 26;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[76].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[76].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[76].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_map_kv(ctx));
        ctx.nonterminal = "_gen20";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 26) {
          tree.add(expect(ctx, 26));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen20",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen3(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[1][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(59, '_gen3'));
    ctx.nonterminal = "_gen3";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[59].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[59].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[59].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_declaration(ctx));
        ctx.nonterminal = "_gen3";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen4(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[51][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(109, '_gen4'));
    ctx.nonterminal = "_gen4";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[109].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[109].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[109].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_sections(ctx));
        ctx.nonterminal = "_gen4";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen5(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[40][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(98, '_gen5'));
    ctx.nonterminal = "_gen5";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[98].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[98].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[98].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_command_part(ctx));
        ctx.nonterminal = "_gen5";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen6(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[20][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(78, '_gen6'));
    ctx.nonterminal = "_gen6";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[78].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[78].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[78].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_cmd_param_kv(ctx));
        ctx.nonterminal = "_gen6";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen7(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[54][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(112, '_gen7'));
    ctx.nonterminal = "_gen7";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[112].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[112].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[112].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_output_kv(ctx));
        ctx.nonterminal = "_gen7";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen8(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[21][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(79, '_gen8'));
    ctx.nonterminal = "_gen8";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[79].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[79].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[79].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_kv(ctx));
        ctx.nonterminal = "_gen8";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen11(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[36][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(94, '_gen11'));
    ctx.nonterminal = "_gen11";
    if (current != null && nonterminal_follow[94].indexOf(current.id) != -1 && nonterminal_first[94].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 49) { // $_gen11 = $alias
        ctx.rule = rules[49];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_alias(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse__gen12(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[23][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(81, '_gen12'));
    ctx.nonterminal = "_gen12";
    if (current != null && nonterminal_follow[81].indexOf(current.id) != -1 && nonterminal_first[81].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 51) { // $_gen12 = $call_body
        ctx.rule = rules[51];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_call_body(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse__gen16(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[42][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(100, '_gen16'));
    ctx.nonterminal = "_gen16";
    if (current != null && nonterminal_follow[100].indexOf(current.id) != -1 && nonterminal_first[100].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 65) { // $_gen16 = $wf_output_wildcard
        ctx.rule = rules[65];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_output_wildcard(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse__gen2(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[14][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(72, '_gen2'));
    ctx.nonterminal = "_gen2";
    if (current != null && nonterminal_follow[72].indexOf(current.id) != -1 && nonterminal_first[72].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 6) { // $_gen2 = $import_namespace
        ctx.rule = rules[6];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_import_namespace(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse__gen9(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[16][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(74, '_gen9'));
    ctx.nonterminal = "_gen9";
    if (current != null && nonterminal_follow[74].indexOf(current.id) != -1 && nonterminal_first[74].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 34) { // $_gen9 = $setter
        ctx.rule = rules[34];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_setter(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse_alias(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[9][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(67, 'alias'));
    ctx.nonterminal = "alias";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 59) { // $alias = :as :identifier -> $1
        ctx.rule = rules[59];
        tree.astTransform = new AstTransformSubstitution(1);
        t = expect(ctx, 34); // :as
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[67],
        rules[59]
    ));
}
function parse_call(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[34][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(92, 'call'));
    ctx.nonterminal = "call";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 53) { // $call = :call :fqn $_gen11 $_gen12 -> Call( task=$1, alias=$2, body=$3 )
        ctx.rule = rules[53];
        ast_parameters = {
            'task': 1,
            'alias': 2,
            'body': 3,
        }
        tree.astTransform = new AstTransformNodeCreator('Call', ast_parameters);
        t = expect(ctx, 2); // :call
        tree.add(t);
        t = expect(ctx, 1); // :fqn
        tree.add(t);
        subtree = parse__gen11(ctx);
        tree.add(subtree);
        subtree = parse__gen12(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[92],
        rules[53]
    ));
}
function parse_call_body(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[32][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(90, 'call_body'));
    ctx.nonterminal = "call_body";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 55) { // $call_body = :lbrace $_gen3 $_gen13 :rbrace -> CallBody( declarations=$1, io=$2 )
        ctx.rule = rules[55];
        ast_parameters = {
            'declarations': 1,
            'io': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('CallBody', ast_parameters);
        t = expect(ctx, 7); // :lbrace
        tree.add(t);
        subtree = parse__gen3(ctx);
        tree.add(subtree);
        subtree = parse__gen13(ctx);
        tree.add(subtree);
        t = expect(ctx, 13); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[90],
        rules[55]
    ));
}
function parse_call_input(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[11][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(69, 'call_input'));
    ctx.nonterminal = "call_input";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 57) { // $call_input = :input :colon $_gen14 -> Inputs( map=$2 )
        ctx.rule = rules[57];
        ast_parameters = {
            'map': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Inputs', ast_parameters);
        t = expect(ctx, 51); // :input
        tree.add(t);
        t = expect(ctx, 53); // :colon
        tree.add(t);
        subtree = parse__gen14(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[69],
        rules[57]
    ));
}
function parse_cmd_param(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[28][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(86, 'cmd_param'));
    ctx.nonterminal = "cmd_param";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 23) { // $cmd_param = :cmd_param_start $_gen6 $e :cmd_param_end -> CommandParameter( attributes=$1, expr=$2 )
        ctx.rule = rules[23];
        ast_parameters = {
            'attributes': 1,
            'expr': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('CommandParameter', ast_parameters);
        t = expect(ctx, 38); // :cmd_param_start
        tree.add(t);
        subtree = parse__gen6(ctx);
        tree.add(subtree);
        subtree = parse_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 23); // :cmd_param_end
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[86],
        rules[23]
    ));
}
function parse_cmd_param_kv(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[55][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(113, 'cmd_param_kv'));
    ctx.nonterminal = "cmd_param_kv";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 24) { // $cmd_param_kv = :cmd_attr_hint :identifier :equal $e -> CommandParameterAttr( key=$1, value=$3 )
        ctx.rule = rules[24];
        ast_parameters = {
            'key': 1,
            'value': 3,
        }
        tree.astTransform = new AstTransformNodeCreator('CommandParameterAttr', ast_parameters);
        t = expect(ctx, 37); // :cmd_attr_hint
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 48); // :equal
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[113],
        rules[24]
    ));
}
function parse_command(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[59][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(117, 'command'));
    ctx.nonterminal = "command";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 19) { // $command = :raw_command :raw_cmd_start $_gen5 :raw_cmd_end -> RawCommand( parts=$2 )
        ctx.rule = rules[19];
        ast_parameters = {
            'parts': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('RawCommand', ast_parameters);
        t = expect(ctx, 35); // :raw_command
        tree.add(t);
        t = expect(ctx, 6); // :raw_cmd_start
        tree.add(t);
        subtree = parse__gen5(ctx);
        tree.add(subtree);
        t = expect(ctx, 50); // :raw_cmd_end
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[117],
        rules[19]
    ));
}
function parse_command_part(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[56][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(114, 'command_part'));
    ctx.nonterminal = "command_part";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 20) { // $command_part = :cmd_part
        ctx.rule = rules[20];
        tree.astTransform = new AstTransformSubstitution(0);
        t = expect(ctx, 54); // :cmd_part
        tree.add(t);
        return tree;
    }
    else if (rule == 21) { // $command_part = $cmd_param
        ctx.rule = rules[21];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_cmd_param(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[114],
        rules[21]
    ));
}
function parse_declaration(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[27][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(85, 'declaration'));
    ctx.nonterminal = "declaration";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 36) { // $declaration = $type_e :identifier $_gen9 -> Declaration( type=$0, name=$1, expression=$2 )
        ctx.rule = rules[36];
        ast_parameters = {
            'type': 0,
            'name': 1,
            'expression': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Declaration', ast_parameters);
        subtree = parse_type_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        subtree = parse__gen9(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[85],
        rules[36]
    ));
}
function parse_document(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[10][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(68, 'document'));
    ctx.nonterminal = "document";
    if (current != null && nonterminal_follow[68].indexOf(current.id) != -1 && nonterminal_first[68].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 2) { // $document = $_gen0 $_gen1 -> Namespace( imports=$0, body=$1 )
        ctx.rule = rules[2];
        ast_parameters = {
            'imports': 0,
            'body': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('Namespace', ast_parameters);
        subtree = parse__gen0(ctx);
        tree.add(subtree);
        subtree = parse__gen1(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse_if_stmt(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[7][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(65, 'if_stmt'));
    ctx.nonterminal = "if_stmt";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 72) { // $if_stmt = :if :lparen $e :rparen :lbrace $_gen10 :rbrace -> If( expression=$2, body=$5 )
        ctx.rule = rules[72];
        ast_parameters = {
            'expression': 2,
            'body': 5,
        }
        tree.astTransform = new AstTransformNodeCreator('If', ast_parameters);
        t = expect(ctx, 41); // :if
        tree.add(t);
        t = expect(ctx, 47); // :lparen
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 17); // :rparen
        tree.add(t);
        t = expect(ctx, 7); // :lbrace
        tree.add(t);
        subtree = parse__gen10(ctx);
        tree.add(subtree);
        t = expect(ctx, 13); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[65],
        rules[72]
    ));
}
function parse_import(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[46][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(104, 'import'));
    ctx.nonterminal = "import";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 8) { // $import = :import :string $_gen2 -> Import( uri=$1, namespace=$2 )
        ctx.rule = rules[8];
        ast_parameters = {
            'uri': 1,
            'namespace': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Import', ast_parameters);
        t = expect(ctx, 49); // :import
        tree.add(t);
        t = expect(ctx, 46); // :string
        tree.add(t);
        subtree = parse__gen2(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[104],
        rules[8]
    ));
}
function parse_import_namespace(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[17][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(75, 'import_namespace'));
    ctx.nonterminal = "import_namespace";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 9) { // $import_namespace = :as :identifier -> $1
        ctx.rule = rules[9];
        tree.astTransform = new AstTransformSubstitution(1);
        t = expect(ctx, 34); // :as
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[75],
        rules[9]
    ));
}
function parse_kv(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[43][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(101, 'kv'));
    ctx.nonterminal = "kv";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 33) { // $kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )
        ctx.rule = rules[33];
        ast_parameters = {
            'key': 0,
            'value': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('RuntimeAttribute', ast_parameters);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 53); // :colon
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[101],
        rules[33]
    ));
}
function parse_map(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[37][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(95, 'map'));
    ctx.nonterminal = "map";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 32) { // $map = :lbrace $_gen8 :rbrace -> $1
        ctx.rule = rules[32];
        tree.astTransform = new AstTransformSubstitution(1);
        t = expect(ctx, 7); // :lbrace
        tree.add(t);
        subtree = parse__gen8(ctx);
        tree.add(subtree);
        t = expect(ctx, 13); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[95],
        rules[32]
    ));
}
function parse_map_kv(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[47][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(105, 'map_kv'));
    ctx.nonterminal = "map_kv";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 38) { // $map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )
        ctx.rule = rules[38];
        ast_parameters = {
            'key': 0,
            'value': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('MapLiteralKv', ast_parameters);
        subtree = parse_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 53); // :colon
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[105],
        rules[38]
    ));
}
function parse_mapping(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[29][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(87, 'mapping'));
    ctx.nonterminal = "mapping";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 58) { // $mapping = :identifier :equal $e -> IOMapping( key=$0, value=$2 )
        ctx.rule = rules[58];
        ast_parameters = {
            'key': 0,
            'value': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('IOMapping', ast_parameters);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 48); // :equal
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[87],
        rules[58]
    ));
}
function parse_meta(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[4][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(62, 'meta'));
    ctx.nonterminal = "meta";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 30) { // $meta = :meta $map -> Meta( map=$1 )
        ctx.rule = rules[30];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('Meta', ast_parameters);
        t = expect(ctx, 57); // :meta
        tree.add(t);
        subtree = parse_map(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[62],
        rules[30]
    ));
}
function parse_object_kv(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[3][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(61, 'object_kv'));
    ctx.nonterminal = "object_kv";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 74) { // $object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )
        ctx.rule = rules[74];
        ast_parameters = {
            'key': 0,
            'value': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('ObjectKV', ast_parameters);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 53); // :colon
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[61],
        rules[74]
    ));
}
function parse_output_kv(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[50][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(108, 'output_kv'));
    ctx.nonterminal = "output_kv";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 27) { // $output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )
        ctx.rule = rules[27];
        ast_parameters = {
            'type': 0,
            'name': 1,
            'expression': 3,
        }
        tree.astTransform = new AstTransformNodeCreator('Output', ast_parameters);
        subtree = parse_type_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 48); // :equal
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[108],
        rules[27]
    ));
}
function parse_outputs(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[52][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(110, 'outputs'));
    ctx.nonterminal = "outputs";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 26) { // $outputs = :output :lbrace $_gen7 :rbrace -> Outputs( attributes=$2 )
        ctx.rule = rules[26];
        ast_parameters = {
            'attributes': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Outputs', ast_parameters);
        t = expect(ctx, 33); // :output
        tree.add(t);
        t = expect(ctx, 7); // :lbrace
        tree.add(t);
        subtree = parse__gen7(ctx);
        tree.add(subtree);
        t = expect(ctx, 13); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[110],
        rules[26]
    ));
}
function parse_parameter_meta(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[53][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(111, 'parameter_meta'));
    ctx.nonterminal = "parameter_meta";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 29) { // $parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )
        ctx.rule = rules[29];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('ParameterMeta', ast_parameters);
        t = expect(ctx, 45); // :parameter_meta
        tree.add(t);
        subtree = parse_map(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[111],
        rules[29]
    ));
}
function parse_runtime(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[39][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(97, 'runtime'));
    ctx.nonterminal = "runtime";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 28) { // $runtime = :runtime $map -> Runtime( map=$1 )
        ctx.rule = rules[28];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('Runtime', ast_parameters);
        t = expect(ctx, 55); // :runtime
        tree.add(t);
        subtree = parse_map(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[97],
        rules[28]
    ));
}
function parse_scatter(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[31][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(89, 'scatter'));
    ctx.nonterminal = "scatter";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 73) { // $scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen10 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )
        ctx.rule = rules[73];
        ast_parameters = {
            'item': 2,
            'collection': 4,
            'body': 7,
        }
        tree.astTransform = new AstTransformNodeCreator('Scatter', ast_parameters);
        t = expect(ctx, 20); // :scatter
        tree.add(t);
        t = expect(ctx, 47); // :lparen
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 36); // :in
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 17); // :rparen
        tree.add(t);
        t = expect(ctx, 7); // :lbrace
        tree.add(t);
        subtree = parse__gen10(ctx);
        tree.add(subtree);
        t = expect(ctx, 13); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[89],
        rules[73]
    ));
}
function parse_sections(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[48][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(106, 'sections'));
    ctx.nonterminal = "sections";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 13) { // $sections = $command
        ctx.rule = rules[13];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_command(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 14) { // $sections = $outputs
        ctx.rule = rules[14];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_outputs(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 15) { // $sections = $runtime
        ctx.rule = rules[15];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_runtime(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 16) { // $sections = $parameter_meta
        ctx.rule = rules[16];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_parameter_meta(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 17) { // $sections = $meta
        ctx.rule = rules[17];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_meta(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[106],
        rules[17]
    ));
}
function parse_setter(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[6][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(64, 'setter'));
    ctx.nonterminal = "setter";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 37) { // $setter = :equal $e -> $1
        ctx.rule = rules[37];
        tree.astTransform = new AstTransformSubstitution(1);
        t = expect(ctx, 48); // :equal
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[64],
        rules[37]
    ));
}
function parse_task(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[26][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(84, 'task'));
    ctx.nonterminal = "task";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 12) { // $task = :task :identifier :lbrace $_gen3 $_gen4 :rbrace -> Task( name=$1, declarations=$3, sections=$4 )
        ctx.rule = rules[12];
        ast_parameters = {
            'name': 1,
            'declarations': 3,
            'sections': 4,
        }
        tree.astTransform = new AstTransformNodeCreator('Task', ast_parameters);
        t = expect(ctx, 56); // :task
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 7); // :lbrace
        tree.add(t);
        subtree = parse__gen3(ctx);
        tree.add(subtree);
        subtree = parse__gen4(ctx);
        tree.add(subtree);
        t = expect(ctx, 13); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[84],
        rules[12]
    ));
}
function parse_wf_body_element(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[38][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(96, 'wf_body_element'));
    ctx.nonterminal = "wf_body_element";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 41) { // $wf_body_element = $call
        ctx.rule = rules[41];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_call(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 42) { // $wf_body_element = $declaration
        ctx.rule = rules[42];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_declaration(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 43) { // $wf_body_element = $while_loop
        ctx.rule = rules[43];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_while_loop(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 44) { // $wf_body_element = $if_stmt
        ctx.rule = rules[44];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_if_stmt(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 45) { // $wf_body_element = $scatter
        ctx.rule = rules[45];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_scatter(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 46) { // $wf_body_element = $wf_outputs
        ctx.rule = rules[46];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_outputs(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 47) { // $wf_body_element = $wf_parameter_meta
        ctx.rule = rules[47];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_parameter_meta(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 48) { // $wf_body_element = $wf_meta
        ctx.rule = rules[48];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_meta(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[96],
        rules[48]
    ));
}
function parse_wf_meta(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[35][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(93, 'wf_meta'));
    ctx.nonterminal = "wf_meta";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 70) { // $wf_meta = :meta $map -> Meta( map=$1 )
        ctx.rule = rules[70];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('Meta', ast_parameters);
        t = expect(ctx, 57); // :meta
        tree.add(t);
        subtree = parse_map(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[93],
        rules[70]
    ));
}
function parse_wf_output(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[2][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(60, 'wf_output'));
    ctx.nonterminal = "wf_output";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 62) { // $wf_output = $wf_output_declaration_syntax
        ctx.rule = rules[62];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_output_declaration_syntax(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 63) { // $wf_output = $wf_output_wildcard_syntax
        ctx.rule = rules[63];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_output_wildcard_syntax(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[60],
        rules[63]
    ));
}
function parse_wf_output_declaration_syntax(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[12][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(70, 'wf_output_declaration_syntax'));
    ctx.nonterminal = "wf_output_declaration_syntax";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 64) { // $wf_output_declaration_syntax = $type_e :identifier :equal $e -> WorkflowOutputDeclaration( type=$0, name=$1, expression=$3 )
        ctx.rule = rules[64];
        ast_parameters = {
            'type': 0,
            'name': 1,
            'expression': 3,
        }
        tree.astTransform = new AstTransformNodeCreator('WorkflowOutputDeclaration', ast_parameters);
        subtree = parse_type_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 48); // :equal
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[70],
        rules[64]
    ));
}
function parse_wf_output_wildcard(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[25][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(83, 'wf_output_wildcard'));
    ctx.nonterminal = "wf_output_wildcard";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 68) { // $wf_output_wildcard = :dot :asterisk -> $1
        ctx.rule = rules[68];
        tree.astTransform = new AstTransformSubstitution(1);
        t = expect(ctx, 5); // :dot
        tree.add(t);
        t = expect(ctx, 40); // :asterisk
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[83],
        rules[68]
    ));
}
function parse_wf_output_wildcard_syntax(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[13][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(71, 'wf_output_wildcard_syntax'));
    ctx.nonterminal = "wf_output_wildcard_syntax";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 67) { // $wf_output_wildcard_syntax = :fqn $_gen16 -> WorkflowOutputWildcard( fqn=$0, wildcard=$1 )
        ctx.rule = rules[67];
        ast_parameters = {
            'fqn': 0,
            'wildcard': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('WorkflowOutputWildcard', ast_parameters);
        t = expect(ctx, 1); // :fqn
        tree.add(t);
        subtree = parse__gen16(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[71],
        rules[67]
    ));
}
function parse_wf_outputs(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[15][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(73, 'wf_outputs'));
    ctx.nonterminal = "wf_outputs";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 61) { // $wf_outputs = :output :lbrace $_gen15 :rbrace -> WorkflowOutputs( outputs=$2 )
        ctx.rule = rules[61];
        ast_parameters = {
            'outputs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('WorkflowOutputs', ast_parameters);
        t = expect(ctx, 33); // :output
        tree.add(t);
        t = expect(ctx, 7); // :lbrace
        tree.add(t);
        subtree = parse__gen15(ctx);
        tree.add(subtree);
        t = expect(ctx, 13); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[73],
        rules[61]
    ));
}
function parse_wf_parameter_meta(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[44][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(102, 'wf_parameter_meta'));
    ctx.nonterminal = "wf_parameter_meta";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 69) { // $wf_parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )
        ctx.rule = rules[69];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('ParameterMeta', ast_parameters);
        t = expect(ctx, 45); // :parameter_meta
        tree.add(t);
        subtree = parse_map(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[102],
        rules[69]
    ));
}
function parse_while_loop(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[41][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(99, 'while_loop'));
    ctx.nonterminal = "while_loop";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 71) { // $while_loop = :while :lparen $e :rparen :lbrace $_gen10 :rbrace -> WhileLoop( expression=$2, body=$5 )
        ctx.rule = rules[71];
        ast_parameters = {
            'expression': 2,
            'body': 5,
        }
        tree.astTransform = new AstTransformNodeCreator('WhileLoop', ast_parameters);
        t = expect(ctx, 24); // :while
        tree.add(t);
        t = expect(ctx, 47); // :lparen
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 17); // :rparen
        tree.add(t);
        t = expect(ctx, 7); // :lbrace
        tree.add(t);
        subtree = parse__gen10(ctx);
        tree.add(subtree);
        t = expect(ctx, 13); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[99],
        rules[71]
    ));
}
function parse_workflow(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[45][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(103, 'workflow'));
    ctx.nonterminal = "workflow";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 40) { // $workflow = :workflow :identifier :lbrace $_gen10 :rbrace -> Workflow( name=$1, body=$3 )
        ctx.rule = rules[40];
        ast_parameters = {
            'name': 1,
            'body': 3,
        }
        tree.astTransform = new AstTransformNodeCreator('Workflow', ast_parameters);
        t = expect(ctx, 31); // :workflow
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 7); // :lbrace
        tree.add(t);
        subtree = parse__gen10(ctx);
        tree.add(subtree);
        t = expect(ctx, 13); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[103],
        rules[40]
    ));
}
function parse_workflow_or_task_or_decl(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[19][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(77, 'workflow_or_task_or_decl'));
    ctx.nonterminal = "workflow_or_task_or_decl";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 3) { // $workflow_or_task_or_decl = $workflow
        ctx.rule = rules[3];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_workflow(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 4) { // $workflow_or_task_or_decl = $task
        ctx.rule = rules[4];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_task(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 5) { // $workflow_or_task_or_decl = $declaration
        ctx.rule = rules[5];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_declaration(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[77],
        rules[5]
    ));
}
// Section: Lexer
// START USER CODE
function init() {
    return {wf_or_task: null};
}
function workflow(ctx, terminal, source_string, line, col) {
    ctx.user_context.wf_or_task = "workflow";
    default_action(ctx, terminal, source_string, line, col);
}
function task(ctx, terminal, source_string, line, col) {
    ctx.user_context.wf_or_task = "task";
    default_action(ctx, terminal, source_string, line, col);
}
function output(ctx, terminal, source_string, line, col) {
    const user_ctx = ctx.user_context;
    if (user_ctx.wf_or_task != null && user_ctx.wf_or_task === "workflow") {
        ctx.mode_stack.push("wf_output");
    }
    default_action(ctx, terminal, source_string, line, col);
}
function wdl_unescape(ctx, terminal, source_string, line, col) {
    var strip_slashes = function(str) {
       return str
           .replace(/\\(.?)/g, function (s, n1) {
             var escapes = {
                 '\\': '\\', 
                 '0' : '\u0000', 
                 ''  : '', 
                 'n' : '\n',
                 'r' : '\r',
                 'b' : '\b',
                 't' : '\t',
                 'f' : '\f',
                 'a' : '\a',
                 'v' : '\v'};
             var symbol = escapes[n1];
             if (symbol !== undefined) {
                 return symbol;
             }
             return n1;
           });
    }
    var repl_str = strip_slashes(source_string.substring(1, source_string.length - 1));
    default_action(ctx, terminal, repl_str, line, col);
}
// END USER CODE
function emit(ctx, terminal, source_string, line, col) {
    ctx.tokens.push(new Terminal(terminals[terminal], terminal, source_string, ctx.resource, line, col))
}
function default_action(ctx, terminal, source_string, line, col) {
    emit(ctx, terminal, source_string, line, col)
}
function destroy(context) {
    return 0;
}
var regex = {
    'default': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("/\\*(.*?)\\*/", "m"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("#.*"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("task(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'task',
                  group: 0,
                  function: task,
              },
          ]
      },
      {
          regex: new RegExp("(call)\\s+"),
          outputs: [
              {
                  terminal: 'call',
                  group: 1,
                  function: null,
              },
              {
                  stack_push: 'task_fqn',
              },
          ]
      },
      {
          regex: new RegExp("workflow(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'workflow',
                  group: 0,
                  function: workflow,
              },
          ]
      },
      {
          regex: new RegExp("import(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'import',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("input(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'input',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("output(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'output',
                  group: 0,
                  function: output,
              },
          ]
      },
      {
          regex: new RegExp("as(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'as',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("if(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'if',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("then(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'then',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("else(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'else',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("while(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'while',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("runtime(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'runtime',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("scatter(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'scatter',
                  group: 0,
                  function: null,
              },
              {
                  stack_push: 'scatter',
              },
          ]
      },
      {
          regex: new RegExp("command\\s*(?=<<<)"),
          outputs: [
              {
                  terminal: 'raw_command',
                  group: 0,
                  function: null,
              },
              {
                  stack_push: 'raw_command2',
              },
          ]
      },
      {
          regex: new RegExp("command\\s*(?=\\{)"),
          outputs: [
              {
                  terminal: 'raw_command',
                  group: 0,
                  function: null,
              },
              {
                  stack_push: 'raw_command',
              },
          ]
      },
      {
          regex: new RegExp("parameter_meta(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'parameter_meta',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("meta(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'meta',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(true|false)(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'boolean',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(object)\\s*(\\{)"),
          outputs: [
              {
                  terminal: 'object',
                  group: 0,
                  function: null,
              },
              {
                  terminal: 'lbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'type',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
          outputs: [
              {
                  terminal: 'identifier',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\\"([^\\\\\\\"\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*\\\\?\""),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp("'([^\\\\\\'\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*'"),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp(":"),
          outputs: [
              {
                  terminal: 'colon',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(","),
          outputs: [
              {
                  terminal: 'comma',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("=="),
          outputs: [
              {
                  terminal: 'double_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\|\\|"),
          outputs: [
              {
                  terminal: 'double_pipe',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\&\\&"),
          outputs: [
              {
                  terminal: 'double_ampersand',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!="),
          outputs: [
              {
                  terminal: 'not_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("="),
          outputs: [
              {
                  terminal: 'equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\{"),
          outputs: [
              {
                  terminal: 'lbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\}"),
          outputs: [
              {
                  terminal: 'rbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\("),
          outputs: [
              {
                  terminal: 'lparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\)"),
          outputs: [
              {
                  terminal: 'rparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\["),
          outputs: [
              {
                  terminal: 'lsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\]"),
          outputs: [
              {
                  terminal: 'rsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\+"),
          outputs: [
              {
                  terminal: 'plus',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("-"),
          outputs: [
              {
                  terminal: 'dash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("/"),
          outputs: [
              {
                  terminal: 'slash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("%"),
          outputs: [
              {
                  terminal: 'percent',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<="),
          outputs: [
              {
                  terminal: 'lteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<"),
          outputs: [
              {
                  terminal: 'lt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">="),
          outputs: [
              {
                  terminal: 'gteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">"),
          outputs: [
              {
                  terminal: 'gt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!"),
          outputs: [
              {
                  terminal: 'not',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\?"),
          outputs: [
              {
                  terminal: 'qmark',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("-?[0-9]+\\.[0-9]+"),
          outputs: [
              {
                  terminal: 'float',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[0-9]+"),
          outputs: [
              {
                  terminal: 'integer',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'wf_output': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("#.*"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'type',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
              {
                  stack_push: 'wf_output_declaration',
              },
          ]
      },
      {
          regex: new RegExp("\\{"),
          outputs: [
              {
                  terminal: 'lbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\}"),
          outputs: [
              {
                  terminal: 'rbrace',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp(","),
          outputs: [
              {
                  terminal: 'comma',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*(\\.[a-zA-Z]([a-zA-Z0-9_])*)*"),
          outputs: [
              {
                  terminal: 'fqn',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'wf_output_declaration': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("#.*"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("\\}"),
          outputs: [
              {
                  terminal: 'rbrace',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp("\\["),
          outputs: [
              {
                  terminal: 'lsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\]"),
          outputs: [
              {
                  terminal: 'rsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\+"),
          outputs: [
              {
                  terminal: 'plus',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[0-9]+"),
          outputs: [
              {
                  terminal: 'integer',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(true|false)(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'boolean',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("if"),
          outputs: [
              {
                  terminal: 'if',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("else"),
          outputs: [
              {
                  terminal: 'else',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("then"),
          outputs: [
              {
                  terminal: 'then',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'type',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
          outputs: [
              {
                  terminal: 'identifier',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(":"),
          outputs: [
              {
                  terminal: 'colon',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(","),
          outputs: [
              {
                  terminal: 'comma',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("=="),
          outputs: [
              {
                  terminal: 'double_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("="),
          outputs: [
              {
                  terminal: 'equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\|\\|"),
          outputs: [
              {
                  terminal: 'double_pipe',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\&\\&"),
          outputs: [
              {
                  terminal: 'double_ampersand',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!="),
          outputs: [
              {
                  terminal: 'not_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("="),
          outputs: [
              {
                  terminal: 'equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\{"),
          outputs: [
              {
                  terminal: 'lbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\("),
          outputs: [
              {
                  terminal: 'lparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\)"),
          outputs: [
              {
                  terminal: 'rparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\["),
          outputs: [
              {
                  terminal: 'lsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\]"),
          outputs: [
              {
                  terminal: 'rsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\+"),
          outputs: [
              {
                  terminal: 'plus',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("-"),
          outputs: [
              {
                  terminal: 'dash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("/"),
          outputs: [
              {
                  terminal: 'slash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("%"),
          outputs: [
              {
                  terminal: 'percent',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<="),
          outputs: [
              {
                  terminal: 'lteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<"),
          outputs: [
              {
                  terminal: 'lt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">="),
          outputs: [
              {
                  terminal: 'gteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">"),
          outputs: [
              {
                  terminal: 'gt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!"),
          outputs: [
              {
                  terminal: 'not',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\?"),
          outputs: [
              {
                  terminal: 'qmark',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\\"([^\\\\\\\"\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*\\\\?\""),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp("'([^\\\\\\'\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*'"),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp("-?[0-9]+\\.[0-9]+"),
          outputs: [
              {
                  terminal: 'float',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[0-9]+"),
          outputs: [
              {
                  terminal: 'integer',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'task_fqn': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*(\\.[a-zA-Z]([a-zA-Z0-9_])*)*"),
          outputs: [
              {
                  terminal: 'fqn',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
    ],
    'scatter': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("\\("),
          outputs: [
              {
                  terminal: 'lparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("in(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'in',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
          outputs: [
              {
                  terminal: 'identifier',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'raw_command': [
      {
          regex: new RegExp("\\{"),
          outputs: [
              {
                  terminal: 'raw_cmd_start',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\}"),
          outputs: [
              {
                  terminal: 'raw_cmd_end',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp("\\$\\{"),
          outputs: [
              {
                  terminal: 'cmd_param_start',
                  group: 0,
                  function: null,
              },
              {
                  stack_push: 'cmd_param',
              },
          ]
      },
      {
          regex: new RegExp("([\\s\\S]*?)(?=\\$\\{|\\})", "m"),
          outputs: [
              {
                  terminal: 'cmd_part',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'raw_command2': [
      {
          regex: new RegExp("<<<"),
          outputs: [
              {
                  terminal: 'raw_cmd_start',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">>>"),
          outputs: [
              {
                  terminal: 'raw_cmd_end',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp("\\$\\{"),
          outputs: [
              {
                  terminal: 'cmd_param_start',
                  group: 0,
                  function: null,
              },
              {
                  stack_push: 'cmd_param',
              },
          ]
      },
      {
          regex: new RegExp("([\\s\\S]*?)(?=\\$\\{|>>>)", "m"),
          outputs: [
              {
                  terminal: 'cmd_part',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'cmd_param': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("\\}"),
          outputs: [
              {
                  terminal: 'cmd_param_end',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp("\\["),
          outputs: [
              {
                  terminal: 'lsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\]"),
          outputs: [
              {
                  terminal: 'rsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("="),
          outputs: [
              {
                  terminal: 'equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\+"),
          outputs: [
              {
                  terminal: 'plus',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[0-9]+"),
          outputs: [
              {
                  terminal: 'integer',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("if"),
          outputs: [
              {
                  terminal: 'if',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("else"),
          outputs: [
              {
                  terminal: 'else',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("then"),
          outputs: [
              {
                  terminal: 'then',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*(?=\\s*=)"),
          outputs: [
              {
                  terminal: 'cmd_attr_hint',
                  group: null,
                  function: null,
              },
              {
                  terminal: 'identifier',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(true|false)(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'boolean',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'type',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
          outputs: [
              {
                  terminal: 'identifier',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(":"),
          outputs: [
              {
                  terminal: 'colon',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(","),
          outputs: [
              {
                  terminal: 'comma',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("=="),
          outputs: [
              {
                  terminal: 'double_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\|\\|"),
          outputs: [
              {
                  terminal: 'double_pipe',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\&\\&"),
          outputs: [
              {
                  terminal: 'double_ampersand',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!="),
          outputs: [
              {
                  terminal: 'not_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("="),
          outputs: [
              {
                  terminal: 'equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\{"),
          outputs: [
              {
                  terminal: 'lbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\("),
          outputs: [
              {
                  terminal: 'lparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\)"),
          outputs: [
              {
                  terminal: 'rparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\["),
          outputs: [
              {
                  terminal: 'lsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\]"),
          outputs: [
              {
                  terminal: 'rsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\+"),
          outputs: [
              {
                  terminal: 'plus',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("-"),
          outputs: [
              {
                  terminal: 'dash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("/"),
          outputs: [
              {
                  terminal: 'slash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("%"),
          outputs: [
              {
                  terminal: 'percent',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<="),
          outputs: [
              {
                  terminal: 'lteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<"),
          outputs: [
              {
                  terminal: 'lt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">="),
          outputs: [
              {
                  terminal: 'gteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">"),
          outputs: [
              {
                  terminal: 'gt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!"),
          outputs: [
              {
                  terminal: 'not',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\\"([^\\\\\\\"\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*\\\\?\""),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp("'([^\\\\\\'\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*'"),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp("-?[0-9]+\\.[0-9]+"),
          outputs: [
              {
                  terminal: 'float',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[0-9]+"),
          outputs: [
              {
                  terminal: 'integer',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
}
function advance_line_col(string, length, line, col) {
    for (var i = 0; i < length; i++) {
        if (string[i] == '\n') {
            line += 1;
            col = 1;
        } else {
            col += 1;
        }
    }
    return {line: line, col: col}
}
function advance_string(ctx, string) {
    lc = advance_line_col(string, string.length, ctx.line, ctx.col)
    ctx.line = lc.line
    ctx.col = lc.col
    ctx.string = ctx.string.substring(string.length)
}
function _unrecognized_token(string, line, col) {
    var lines = string.split('\n')
    var bad_line = lines[line-1]
    var message = 'Unrecognized token on line {0}, column {1}:\n\n{2}\n{3}'.format(
        line, col, bad_line, Array(col).join(' ') + '^'
    )
    throw new SyntaxError(message)
}
function _next(ctx) {
    var tokens = []
    var mode = ctx.mode_stack[ctx.mode_stack.length - 1]
    for (var i = 0; i < regex[mode].length; i++) {
        match = regex[mode][i].regex.exec(ctx.string);
        if (match != null && match.index == 0) {
            for (var j = 0; j < regex[mode][i].outputs.length; j++) {
                var terminal = regex[mode][i].outputs[j].terminal;
                var group = regex[mode][i].outputs[j].group;
                var func = regex[mode][i].outputs[j].function;
                var stack_push = regex[mode][i].outputs[j].stack_push;
                var action = regex[mode][i].outputs[j].action;
                if (stack_push !== undefined) {
                    ctx.mode_stack.push(stack_push)
                } else if (action !== undefined) {
                    if (action == 'pop') {
                        ctx.mode_stack.pop()
                    }
                } else {
                    func = (func == null) ? default_action : func;
                    var source_string = group != null ? match[group] : ""
                    // Ugh!  JavaScript why you no have regex group indexes?!
                    var group_line = ctx.line
                    var group_col = ctx.col
                    try {
                        var mult_regex = new MultiRegExp(regex[mode][i].regex.source);
                        var mult_groups = mult_regex.exec(ctx.string)
                        if (group != null && group > 0) {
                            var lc = advance_line_col(match[0], mult_groups[group-1].index, ctx.line, ctx.col)
                            group_line = lc.line
                            group_col = lc.col
                        }
                    } catch(err) {}
                    // ^ Literally the worst thing ever
                    func(ctx, terminal, source_string, group_line, group_col)
                }
            }
            advance_string(ctx, match[0])
            return true
        }
    }
    return false
}
function lex(string, resource) {
    ctx = {
        string: string,
        resource: resource,
        user_context: init(),
        mode_stack: ['default'],
        tokens: [],
        line: 1,
        col: 1
    }
    string_copy = string
    parsed_tokens = []
    while (ctx.string.length) {
        matched = _next(ctx)
        if (matched == false) {
            _unrecognized_token(string_copy, ctx.line, ctx.col)
        }
    }
    destroy(ctx.user_context)
    return new TokenStream(ctx.tokens)
}
// Section: Main
// Section: Exports
module.exports = {
  lex: lex,
  parse: parse,
  terminals: terminals,
  parse_tree_string: parse_tree_string,
  ast_string: ast_string
}
