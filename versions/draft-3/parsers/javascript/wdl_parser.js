
/*
 * This file was generated by Hermes Parser Generator on Mon Apr 16 18:09:18 2018
 * 
 * Hermes command: hermes generate ../grammar.hgr --language=javascript --name=wdl --nodejs --header --directory .
 * Run from: . (relative to this file)
 * Hermes version: hermes-parser 2.0rc6
 * 
 * !!! DO NOT CHANGE THIS FILE DIRECTLY !!!
 * 
 * If you wish to change something in this file, either change the grammar and
 * re-generate this file, or change the templates in Hermes and regenerate.
 * See the Hermes repository: http://github.com/scottfrazer/hermes
 */
if (!String.prototype.format) {
    String.prototype.format = function() {
        var args = arguments;
        return this.replace(/{(\d+)}/g, function(match, number) {
            return typeof args[number] != 'undefined' ? args[number]: match;
        });
    };
}
String.prototype.lstrip = function() {
    return this.replace(/^\s*/g, "");
}
function parse_tree_string(parsetree, indent, b64_source) {
    return _parse_tree_string(parsetree, indent, b64_source, 0);
}
function _parse_tree_string(parsetree, indent, b64_source, indent_level) {
    if (typeof(indent) != 'number' || indent <= 0) {
        indent = undefined
    }
    var indent_str = typeof(indent) !== 'undefined' ? Array(indent * indent_level + 1).join(' ') : ''
    if (parsetree instanceof ParseTree) {
        var children = []
        for (var i in parsetree.children) {
            children.push(_parse_tree_string(parsetree.children[i], indent, b64_source, indent_level + 1))
        }
        if (typeof(indent) == 'undefined' || children.length == 0) {
            return '{0}({1}: {2})'.format(indent_str, parsetree.nonterminal.to_string(), children.join(', '))
        } else {
            return '{0}({1}:\n{2}\n{3})'.format(
                indent_str,
                parsetree.nonterminal.to_string(),
                children.join(',\n'),
                indent_str
            )
        }
    } else if (parsetree instanceof Terminal) {
        return indent_str + parsetree.to_string(b64_source)
    }
}
function ast_string(ast, indent, b64_source) {
    return _ast_string(ast, indent, b64_source, 0);
}
function _ast_string(ast, indent, b64_source, indent_level) {
    if (typeof(indent) != 'number' || indent <= 0) {
        indent = undefined
    }
    var indent_str = typeof(indent) !== 'undefined' ? Array(indent * indent_level + 1).join(' ') : ''
    var next_indent_str = typeof(indent) !== 'undefined' ? Array(indent * (indent_level+1) + 1).join(' ') : ''
    if (ast instanceof Ast) {
        var children = {}
        for (var key in ast.attributes) {
            children[key] = _ast_string(ast.attributes[key], indent, b64_source, indent_level + 1)
        }
        if (typeof(indent) == 'undefined') {
            var strs = []
            for (var key in children) {
                strs.push('{0}={1}'.format(key, children[key]))
            }
            return '({0}: {1})'.format(
                ast.name,
                strs.join(', ')
            )
        } else {
            var strs = []
            for (var key in children) {
                strs.push('{0}{1}={2}'.format(next_indent_str, key, children[key]))
            }
            return '({0}:\n{1}\n{2})'.format(
                ast.name,
                strs.join(',\n'),
                indent_str
            )
        }
    } else if (ast instanceof AstList) {
        var children = []
        for (var key in ast.list) {
            children.push(_ast_string(ast.list[key], indent, b64_source, indent_level + 1))
        }
        if (typeof(indent) == 'undefined' || children.length == 0) {
            return '[{0}]'.format(children.join(', '))
        } else {
            var strs = []
            for (var index in children) {
                strs.push('{0}{1}'.format(next_indent_str, children[index]))
            }
            return '[\n{0}\n{1}]'.format(
                strs.join(',\n'),
                indent_str
            )
        }
    } else if (ast instanceof Terminal) {
        return ast.to_string(b64_source)
    } else {
        return (ast == null) ? 'None' : ast.to_string()
    }
}
function Terminal(id, str, source_string, resource, line, col) {
    this.id = id;
    this.str = str;
    this.source_string = source_string;
    this.resource = resource;
    this.line = line;
    this.col = col;
    this.to_ast = function() {
        return this;
    };
    this.to_string = function(b64_source) {
        return '<{0}:{1}:{2} {3} "{4}">'.format(
            this.resource,
            this.line,
            this.col,
            this.str,
            b64_source ? Base64.encode(this.source_string) : this.source_string
        )
    };
}
function NonTerminal(id, str) {
    this.id = id;
    this.str = str;
    this.to_string = function() {
        return this.str;
    };
}
function AstTransformSubstitution(idx) {
    this.idx = idx;
    this.to_string = function() {
        return '$' + this.idx;
    };
}
function AstTransformNodeCreator(name, parameters) {
    this.name = name;
    this.parameters = parameters;
    this.to_string = function() {
        var arr = [];
        for ( key in this.parameters ) {
            arr.push('{0}=${1}'.format(key, this.parameters[key]));
        }
        return '{0} ( {1} )'.format(this.name, arr.join(', '));
    };
}
function AstList(list) {
    this.list = list
    this.push = function(element) {
        this.list.push(element);
    };
    this.to_ast = function() {
        var arr = [];
        for (item in this.list) {
            arr.push(item.to_ast());
        }
        return arr;
    };
}
function ParseTree(nonterminal) {
    this.children = [];
    this.nonterminal = nonterminal;
    this.astTransform = null;
    this.isExpr = false;
    this.isNud = false;
    this.isPrefix = false;
    this.isInfix = false;
    this.nudMorphemeCount = 0;
    this.isExprNud = false;
    this.listSeparator = null;
    this.list = false;
    this.add = function(tree) {
        this.children.push(tree);
    }
    this.to_ast = function() {
        if (this.list == true) {
            if (this.children.length == 0) {
                return new AstList([]);
            }
            var end = this.children.length - 1;
            var list = [];
            for (var i = 0; i < this.children.length; i++) {
                if (this.children[i] instanceof Terminal && this.children[i].id == this.listSeparator)
                    continue;
                list.push(this.children[i].to_ast());
            }
            return new AstList(list);
        }
        else if (this.isExpr == true) {
            if (this.astTransform instanceof AstTransformSubstitution) {
                return this.children[this.astTransform.idx].to_ast();
            }
            else if (this.astTransform instanceof AstTransformNodeCreator) {
                var parameters = {}
                for (name in this.astTransform.parameters) {
                    var idx = this.astTransform.parameters[name];
                    var child = null;
                    if (idx == '$') {
                        child = this.children[0];
                    } else if (this.children[0] instanceof ParseTree && this.children[0].isNud && !this.children[0].isPrefix && !this.isExprNud && !this.isInfix) {
                        if (idx < this.children[0].nudMorphemeCount) {
                            child = this.children[0].children[idx]
                        } else {
                            index = idx - this.children[0].nudMorphemeCount + 1
                            child = this.children[index]
                        }
                    } else if (this.children.length == 1 && !(this.children[0] instanceof ParseTree) && !(this.children[0] instanceof Array)) {
                        return this.children[0];
                    } else {
                        child = this.children[idx];
                    }
                    parameters[name] = child.to_ast()
                }
                return new Ast(this.astTransform.name, parameters);
            }
        }
        else {
            if (this.astTransform instanceof AstTransformSubstitution) {
                return this.children[this.astTransform.idx].to_ast()
            } else if (this.astTransform instanceof AstTransformNodeCreator) {
                var parameters = {};
                for (name in this.astTransform.parameters) {
                    parameters[name] = this.children[this.astTransform.parameters[name]].to_ast();
                }
                return new Ast(this.astTransform.name, parameters);
                return x;
            } else if (this.children.length) {
                return this.children[0].to_ast();
            } else {
                return null;
            }
        }
    }
    this.to_string = function() {
        var children = []
        for (i in this.children) {
            var child = this.children[i];
            if (child instanceof Array) {
                var stringify = child.map(function(x) {return x.to_string()});
                children.push('[' + stringify.join(', ') + ']');
            } else {
                children.push(child.to_string());
            }
        }
        return '(' + this.nonterminal.to_string() + ': ' + children.join(', ') + ')'
    }
}
function Ast(name, attributes) {
    this.name = name;
    this.attributes = attributes;
    this.to_string = function() {
        var arr = [];
        for (var key in this.attributes) {
            var value = this.attributes[key];
            if (value instanceof Array) {
                var stringify = value.map(function(x) {return x.to_string()});
                value = '[{0}]'.format(stringify.join(', '));
            } else {
                value = value.to_string();
            }
            arr.push('{0}={1}'.format(key.to_string(), value))
        }
        return '({0}: {1})'.format(this.name, arr.join(', '));
    }
}
function SyntaxError(message) {
    this.message = message;
    this.to_string = function() {
        return this.message;
    }
}
function TokenStream(list) {
    this.list = list;
    this.index = 0;
    this.advance = function() {
        this.index += 1;
        return this.current();
    }
    this.last = function() {
        return this.list[this.list.length - 1];
    }
    this.current = function() {
        if (this.index < this.list.length) {
            return this.list[this.index];
        } else {
            return null;
        }
    }
}
function DefaultSyntaxErrorFormatter() {
    this.unexpected_eof = function(nonterminal, expected_terminals, nonterminal_rules) {
        return "Error: unexpected end of file";
    }
    this.excess_tokens = function(nonterminal, terminal) {
        return "Finished parsing without consuming all tokens.";
    }
    this.unexpected_symbol = function(nonterminal, actual_terminal, expected_terminals, rule) {
        return "Unexpected symbol (line {0}, col {1}) when parsing parse_{2}.  Expected {3}, got {4}.".format(
          actual_terminal.line,
          actual_terminal.col,
          nonterminal,
          expected_terminals.join(', '),
          actual_terminal.to_string(true)
        );
    }
    this.no_more_tokens = function(nonterminal, expected_terminal, last_terminal) {
        return "No more tokens.  Expecting " + expected_terminal;
    }
    this.invalid_terminal = function(nonterminal, invalid_terminal) {
        return "Invalid symbol ID: {0} ({1})".format(invalid_terminal.id, invalid_terminal.string);
    }
    this.missing_list_items = function(method, required, found, last) {
        return "List for "+method+" requires "+required+" items but only "+found+" were found.";
    }
    this.missing_terminator = function(method, terminator, last) {
        return "List for "+method+" is missing a terminator";
    }
}
function ParserContext(tokens, error_formatter) {
    this.tokens = tokens;
    this.error_formatter = error_formatter;
    this.nonterminal_string = null;
    this.rule_string = null;
}
function MultiRegExp(par) {
    var regex;
    if (par.source !== undefined){
        regex = par;
    } else {
        var exp = par;
        var opts = "";
        if (par.substring(0, 1) == "/") {
            var l = par.lastIndexOf("/");
            opts = par.substring(l + 1, par.length);
            exp = par.substring(1, l);
        }
        regex = new RegExp(exp, opts);
    }
    var expandSource = function (braces, indexer) {
        ret = '';
        for (var i = 0; i < braces.length; i++) {
            if (braces[i].type == 'raw') {
                ret += '(' + braces[i].text + ')';
                indexer.next();
            } else if (braces[i].type == 'brace' && braces[i].containsCapture) {
                ret += braces[i].pre + expandSource(braces[i].children, indexer) + braces[i].post;
            } else if (braces[i].type == 'brace' && !braces[i].isCapture) {
                ret += '(' + braces[i].text.substring(braces[i].pre.length, braces[i].text.length - braces[i].post.length) + ')';
                indexer.next();
            } else if (braces[i].type == 'brace') {
                ret += braces[i].text;
                indexer.next(true);
            } else {
                ret += braces[i].text;
            }
        }
        return ret;
    }
    var captureScan = function(braces, parent) {
        var containsCapture = false;
        for (var i = 0; i < braces.length; i++) {
            captureScan(braces[i].children, braces[i]);
            braces[i].isCapture = braces[i].text.indexOf('(?:') != 0;
            if (braces[i].isCapture) {
                containsCapture = true;
            }
            if (braces[i].isCapture && braces[i].containsCapture) {
                throw "nested captures not permitted, use (?:...) where capture is not intended";
            }
        }
        if (parent) {
            parent.containsCapture = containsCapture;
        }
    }
    var fillGaps = function(braces, text) {
        var pre = /^\((\?.)?/.exec(text);
        pre = pre == null ? '' : pre[0];
        var post = /\)$/.exec(text);
        post = post == null ? '' : post[0];
        var i = 0;
        if (braces.length > 0) {
            fillGaps(braces[0].children, braces[0].text);
        }
        if (braces.length > 0 && braces[0].pos > pre.length) {
            braces.splice(0, 0, {type: 'raw', pos: pre.length, length: braces[0].pos, text: text.substring(pre.length, braces[0].pos)});
            i++;
        }
        for(i++ ;i < braces.length; i++) {
            fillGaps(braces[i].children, braces[i].text);
            if (braces[i].pos > braces[i-1].pos + braces[i-1].length) {
                braces.splice(i, 0, {type:'raw', pos: braces[i-1].pos + braces[i-1].length,
                                     length: braces[i].pos - (braces[i-1].pos + braces[i-1].length),
                                     text: text.substring(braces[i-1].pos + braces[i-1].length,
                                                          braces[i].pos)});
                i++;
            }
        }
        if (braces.length == 0)
        {
            braces.push({type:'raw', pos: pre.length, length: text.length - post.length - pre.length, text: text.substring(pre.length, text.length - post.length)});
        } else if (braces[braces.length - 1].pos + braces[braces.length - 1].length < text.length - post.length) { 
            var pos = braces[braces.length - 1].pos + braces[braces.length - 1].length;
            var txt = text.substring(pos, text.length - post.length);
            braces.push({type:'raw', pos: pos, length: txt.length, text: txt});
        }
    }
    var GetBraces = function(text) {
        var ret = [];
        var shift = 0;
        do {
            var brace = GetBrace(text);
            if (brace == null) {
                break;
            } else {
                text = text.substring(brace.pos + brace.length);
                var del = brace.pos + brace.length;
                brace.pos += shift;
                shift += del;
                ret.push(brace);
            }
        } while (brace != null);
        return ret;
    }
    var GetBrace = function(text) {
        var ret = {pos: -1, length: 0, text: '', children: [], type: 'brace'};
        var openExp = /^(?:\\.|[^\)\\\(])*\(\?./;
        var pre = 3;
        var post = 1;
        var m = openExp.exec(text);
        if (m == null) {
            m = /^(?:\\.|[^\)\\\(])*\(/.exec(text);
            pre = 1;
        }
        if (m != null) {
            ret.pos = m[0].length - pre;
            ret.children = GetBraces(text.substring(m[0].length));
            for (var i = 0; i < ret.children.length; i++) {
                ret.children[i].pos += pre;
            }
            var closeExp = /^(?:\\.|[^\\\(\)])*\)/;
            var closeExpAlt = /^(?:\\.|[^\\\(\)])*\)\?/;
            var from = ret.children.length <= 0 ? ret.pos + pre : 
                ret.children[ret.children.length-1].pos + 
                    ret.children[ret.children.length-1].length + 
                    m[0].length - pre;
            var m2 = closeExp.exec(text.substring(from));
            var m3 = closeExpAlt.exec(text.substring(from));
            if (m3 !== null && m3.length - 1 <= m2.length) {
                m2 = m3;
                post = 2;
            }
            if (m2 == null) {
                return null;
            } else {
                ret.length = m2[0].length + from - ret.pos;
                ret.text = text.substring(ret.pos, ret.pos + ret.length);
            }
        }
        if (ret.text == '()' || /^\(\?.\)$/.test(ret.text)) {
            throw 'empty braces not permitted';
        }
        if (ret.pos != -1) {
            ret.pre = ret.text.substring(0, pre);
            ret.post = ret.text.substring(ret.text.length - post, ret.text.length);
        }
        return ret.pos == -1 ? null : ret;
    }
    var fixOrs = function (braces_W_raw) {
        var orFind = /^(\\.|[^\\|])*\|/;
        for (var i = 0; i < braces_W_raw.length; i++) {
            if (braces_W_raw[i].type == 'raw') {
                var fullText = braces_W_raw[i].text;
                var m = orFind.exec(fullText);
                if (m != null) {
                    var or = { type: 'or', pos: m[0].length - 1 + braces_W_raw[i].pos, length: 1, text: '|' };
                    var raw = { type: 'raw', pos: m[0].length + braces_W_raw[i].pos,
                        length: fullText.length - m[0].length,
                        text: fullText.substring(m[0].length, fullText.length)
                    };
                    braces_W_raw[i].text = fullText.substring(0, m[0].length - 1);
                    braces_W_raw[i].length = braces_W_raw[i].text.length;
                    braces_W_raw.splice(i + 1, 0, or, raw);
                    i += 1;
                }
            } else if (braces_W_raw[i].type == 'brace') {
                fixOrs(braces_W_raw[i].children, braces_W_raw[i].text);
            }
        }
    }
    var source = regex.source;
    var braces = GetBraces(source);
    captureScan(braces);
    fillGaps(braces, source);
    fixOrs(braces);
    var indexer = {i: 1, next:
                       function (realPoint) {
                           if (realPoint) {
                               this.points.push(this.i);
                           }
                           return this.i++;
                       }, points: []};
    source = expandSource(braces, indexer);
    this.dataPoints = indexer.points;
    var options = (regex.ignoreCase ? "i" : "") + (regex.global ? "g" : "") + (regex.multiline ? "m" : "");
    this.regex = new RegExp(source, options);
    this.exec = function (text) {
        var m = this.regex.exec(text);
        if (m == null) {
            return {};
        }
        var ret = {};
        var ch = 0;
        for (var i = 1; i < m.length; i++) {
            if (m[i] !== null && m[i] !== undefined) {
                var pos = this.dataPoints.indexOf(i);
                if (pos != -1) {
                    ret[pos] = {index: ch, text: m[i]};
                }
                ch += m[i].length;
            }
        }
        for (var i = 0; i < this.dataPoints.length; i++) {
            if (ret[i] === undefined) {
                ret[i] = null;
            }
        }
        return ret;
    }
}
var Base64 = {
    // private property
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    // public method for encoding
    encode : function (input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        input = Base64._utf8_encode(input);
        while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }
            output = output +
            Base64._keyStr.charAt(enc1) + Base64._keyStr.charAt(enc2) +
            Base64._keyStr.charAt(enc3) + Base64._keyStr.charAt(enc4);
        }
        return output;
    },
    // public method for decoding
    decode : function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
            enc1 = Base64._keyStr.indexOf(input.charAt(i++));
            enc2 = Base64._keyStr.indexOf(input.charAt(i++));
            enc3 = Base64._keyStr.indexOf(input.charAt(i++));
            enc4 = Base64._keyStr.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
                output = output + String.fromCharCode(chr3);
            }
        }
        output = Base64._utf8_decode(output);
        return output;
    },
    // private method for UTF-8 encoding
    _utf8_encode : function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";
        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }
        return utftext;
    },
    // private method for UTF-8 decoding
    _utf8_decode : function (utftext) {
        var string = "";
        var i = 0;
        var c = c1 = c2 = 0;
        while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
        }
        return string;
    }
}
// Section: Parser
var terminals = {
    0: 'while',
    1: 'scatter',
    2: 'gteq',
    3: 'cmd_attr_hint',
    4: 'lteq',
    5: 'then',
    6: 'type_e',
    7: 'cmd_part',
    8: 'import',
    9: 'lt',
    10: 'lparen',
    11: 'task',
    12: 'rparen',
    13: 'gt',
    14: 'string',
    15: 'dot',
    16: 'equal',
    17: 'output',
    18: 'double_ampersand',
    19: 'fqn',
    20: 'raw_command',
    21: 'if',
    22: 'cmd_param_start',
    23: 'null',
    24: 'raw_cmd_end',
    25: 'runtime',
    26: 'lsquare',
    27: 'call',
    28: 'not_equal',
    29: 'slash',
    30: 'integer',
    31: 'double_equal',
    32: 'boolean',
    33: 'e',
    34: 'object',
    35: 'rbrace',
    36: 'float',
    37: 'dash',
    38: 'comma',
    39: 'double_pipe',
    40: 'type',
    41: 'rsquare',
    42: 'input',
    43: 'lbrace',
    44: 'identifier',
    45: 'parameter_meta',
    46: 'asterisk',
    47: 'qmark',
    48: 'plus',
    49: 'else',
    50: 'in',
    51: 'percent',
    52: 'workflow',
    53: 'meta',
    54: 'not',
    55: 'cmd_param_end',
    56: 'colon',
    57: 'raw_cmd_start',
    58: 'as',
    'while': 0,
    'scatter': 1,
    'gteq': 2,
    'cmd_attr_hint': 3,
    'lteq': 4,
    'then': 5,
    'type_e': 6,
    'cmd_part': 7,
    'import': 8,
    'lt': 9,
    'lparen': 10,
    'task': 11,
    'rparen': 12,
    'gt': 13,
    'string': 14,
    'dot': 15,
    'equal': 16,
    'output': 17,
    'double_ampersand': 18,
    'fqn': 19,
    'raw_command': 20,
    'if': 21,
    'cmd_param_start': 22,
    'null': 23,
    'raw_cmd_end': 24,
    'runtime': 25,
    'lsquare': 26,
    'call': 27,
    'not_equal': 28,
    'slash': 29,
    'integer': 30,
    'double_equal': 31,
    'boolean': 32,
    'e': 33,
    'object': 34,
    'rbrace': 35,
    'float': 36,
    'dash': 37,
    'comma': 38,
    'double_pipe': 39,
    'type': 40,
    'rsquare': 41,
    'input': 42,
    'lbrace': 43,
    'identifier': 44,
    'parameter_meta': 45,
    'asterisk': 46,
    'qmark': 47,
    'plus': 48,
    'else': 49,
    'in': 50,
    'percent': 51,
    'workflow': 52,
    'meta': 53,
    'not': 54,
    'cmd_param_end': 55,
    'colon': 56,
    'raw_cmd_start': 57,
    'as': 58,
}
// table[nonterminal][terminal] = rule
var table = [
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, 78, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 78, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, 2, -1, 2, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 67, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, -1, -1, 13, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [49, 49, -1, -1, -1, -1, 49, -1, -1, -1, -1, 49, -1, -1, -1, -1, 48, 49, -1, -1, 49, 49, -1, -1, -1, 49, -1, 49, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, 49, -1, 49, -1, -1, 49, -1, -1, -1, -1, -1, -1, 49, 49, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, 79, -1, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [85, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 45, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, 7, -1, 7, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, 6],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [66, 66, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, -1, 66, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, 66, -1, -1, 65, -1, 66, -1, -1, -1, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 83, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [64, 64, -1, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, 64, -1, -1, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, -1, 64, -1, -1, 64, -1, 64, -1, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, -1, 63],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 73],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, 87, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 32, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, 52, -1, -1, -1, -1, 52, -1, -1, -1, 52, -1, 52, 52, 52, -1, 52, 52, -1, -1, -1, -1, -1, 52, 52, -1, -1, -1, 52, -1, -1, -1, -1, -1, 52, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, -1, -1, -1, -1, -1, -1, 41, -1, -1, 43, -1, -1, -1, 38, -1, 40, -1, -1, -1, 39, -1, -1, -1, -1, -1, -1, 42, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 71, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [57, 59, -1, -1, -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 60, -1, -1, -1, 58, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, -1, -1, -1, -1, 61, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
]
var nonterminal_first = {
    59: [7, 22, -1],
    60: [15],
    61: [6, 40],
    62: [6, 40],
    63: [43],
    64: [-1, 8, 40, 11, 52, 6],
    65: [27],
    66: [53, 20, 25, 45, 17],
    67: [19],
    68: [-1, 3],
    69: [-1, 16],
    70: [15, -1],
    71: [11, 52, 6, 40],
    72: [-1, 44],
    73: [43],
    74: [17],
    75: [16],
    76: [53],
    77: [-1, 44],
    78: [0],
    79: [43],
    80: [44],
    81: [22],
    82: [26],
    83: [-1, 44],
    84: [11],
    85: [17],
    86: [43],
    87: [21],
    88: [-1, 6, 40],
    89: [-1, 58],
    90: [45],
    91: [43, -1],
    92: [45],
    93: [-1, 52, 6, 40, 11],
    94: [-1, 25, 17, 20, 45, 53],
    95: [-1, 6, 40],
    96: [7, 22],
    97: [-1, 58],
    98: [44],
    99: [32, -1, 33, 34, 37, 36, 10, 43, 44, 14, 48, 21, 54, 26, 30],
    100: [6, 40],
    101: [3],
    102: [44],
    103: [58],
    104: [44],
    105: [-1, 40, 19, 6],
    106: [-1, 8],
    107: [0, 1, -1, 17, 6, 53, 21, 27, 40, 45],
    108: [6, 40],
    109: [1],
    110: [-1, 44],
    111: [32, -1, 33, 34, 37, 10, 43, 44, 14, 48, 30, 21, 54, 26, 36],
    112: [53],
    113: [8],
    114: [14, 32, 33, 48, 34, 30, 37, 21, 54, 26, 10, 43, 44, 36],
    115: [52],
    116: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    117: [23, 14, 32, 26, 30, 43, 36],
    118: [25],
    119: [42],
    120: [-1, 44],
    121: [58],
    122: [14, 32, -1, 36, 23, 26, 43, 30],
    123: [19, 6, 40],
    124: [0, 1, 17, 6, 53, 21, 27, 40, 45],
    125: [20],
    126: [-1, 6, 40],
    127: [42, -1],
}
var nonterminal_follow = {
    59: [24],
    60: [40, 35, 19, 6],
    61: [40, 35, 19, 6],
    62: [6, 35, 40],
    63: [0, 1, 17, 35, 20, 6, 53, 21, 27, 25, 40, 45],
    64: [-1],
    65: [0, 1, 17, 35, 6, 53, 21, 27, 40, 45],
    66: [17, 35, 20, 53, 25, 45],
    67: [40, 35, 19, 6],
    68: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    69: [0, 1, 35, 6, 40, 42, 11, -1, 45, 17, 20, 52, 53, 21, 27, 25],
    70: [40, 35, 19, 6],
    71: [52, 6, 40, 11, -1],
    72: [35],
    73: [0, 1, 17, 35, 6, 53, 21, 27, 40, 45],
    74: [0, 1, 17, 35, 6, 53, 21, 27, 40, 45],
    75: [0, 1, 35, 6, 40, 42, 11, -1, 45, 17, 20, 52, 53, 21, 27, 25],
    76: [0, 1, 17, 35, 6, 53, 21, 27, 40, 45],
    77: [35],
    78: [0, 1, 17, 35, 6, 53, 21, 27, 40, 45],
    79: [41, 35, 44, 38],
    80: [42, 38, 35],
    81: [7, 22, 24],
    82: [41, 35, 44, 38],
    83: [35],
    84: [52, 6, 40, 11, -1],
    85: [17, 35, 20, 53, 25, 45],
    86: [17, 35, 20, 53, 25, 45],
    87: [0, 1, 17, 35, 6, 53, 21, 27, 40, 45],
    88: [41],
    89: [8, 40, 6, 11, 52, -1],
    90: [17, 35, 20, 53, 25, 45],
    91: [0, 1, 17, 35, 6, 53, 21, 27, 40, 45],
    92: [0, 1, 17, 35, 6, 53, 21, 27, 40, 45],
    93: [-1],
    94: [35],
    95: [25, 17, 42, 20, 45, 53],
    96: [7, 22, 24],
    97: [0, 1, 17, 35, 6, 53, 21, 27, 40, 43, 45],
    98: [44, 38, 35],
    99: [12, 41],
    100: [0, 1, 35, 6, 40, 42, 11, -1, 45, 17, 20, 52, 53, 21, 27, 25],
    101: [32, 33, 34, 3, 37, 36, 10, 43, 44, 14, 48, 21, 54, 26, 30],
    102: [38, 35],
    103: [0, 1, 17, 35, 6, 53, 21, 27, 40, 43, 45],
    104: [44, 35],
    105: [35],
    106: [-1, 11, 52, 6, 40],
    107: [35],
    108: [44, 38, 41],
    109: [0, 1, 17, 35, 6, 53, 21, 27, 40, 45],
    110: [42, 35],
    111: [35],
    112: [17, 35, 20, 53, 25, 45],
    113: [8, 40, -1, 11, 52, 6],
    114: [38, 35],
    115: [52, 6, 40, 11, -1],
    116: [0, 1, 2, 3, 4, 5, 6, 9, 12, 10, 11, -1, 13, 14, 18, 17, 19, 20, 21, 27, 28, 29, 25, 30, 31, 32, 33, 34, 35, 37, 38, 39, 40, 41, 42, 43, 44, 56, 46, 45, 48, 49, 51, 52, 53, 54, 55, 26, 36],
    117: [44, 38, 41, 35],
    118: [17, 35, 20, 53, 25, 45],
    119: [42, 35],
    120: [35],
    121: [8, 40, -1, 11, 52, 6],
    122: [41],
    123: [40, 35, 19, 6],
    124: [0, 1, 17, 35, 6, 53, 21, 27, 40, 45],
    125: [17, 35, 20, 53, 25, 45],
    126: [35],
    127: [35],
}
var rule_first = {
    0: [-1, 8],
    1: [11, 52, 6, -1, 40],
    2: [-1, 52, 6, 8, 40, 11],
    3: [52],
    4: [11],
    5: [6, 40],
    6: [58],
    7: [-1],
    8: [8],
    9: [58],
    10: [-1, 6, 40],
    11: [-1, 17, 20, 53, 25, 45],
    12: [11],
    13: [20],
    14: [17],
    15: [25],
    16: [45],
    17: [53],
    18: [7, 22, -1],
    19: [20],
    20: [7],
    21: [22],
    22: [-1, 3],
    23: [22],
    24: [3],
    25: [-1, 6, 40],
    26: [17],
    27: [6, 40],
    28: [25],
    29: [44, -1],
    30: [43],
    31: [44],
    32: [53],
    33: [45],
    34: [44, -1],
    35: [43],
    36: [44],
    37: [14],
    38: [30],
    39: [36],
    40: [32],
    41: [23],
    42: [43],
    43: [26],
    44: [44, -1],
    45: [43],
    46: [23, 14, 32, -1, 26, 30, 43, 36],
    47: [26],
    48: [16],
    49: [-1],
    50: [6, 40],
    51: [16],
    52: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    53: [0, 1, -1, 17, 6, 53, 21, 27, 40, 45],
    54: [52],
    55: [27],
    56: [6, 40],
    57: [0],
    58: [21],
    59: [1],
    60: [17],
    61: [45],
    62: [53],
    63: [58],
    64: [-1],
    65: [43],
    66: [-1],
    67: [27],
    68: [42, -1],
    69: [43],
    70: [44, -1],
    71: [42],
    72: [44],
    73: [58],
    74: [19, -1, 6, 40],
    75: [17],
    76: [6, 40],
    77: [19],
    78: [6, 40],
    79: [15],
    80: [-1],
    81: [19],
    82: [15],
    83: [45],
    84: [53],
    85: [0],
    86: [21],
    87: [1],
    88: [44],
    89: [-1, 6, 40],
    90: [40],
    91: [40],
    92: [40],
    93: [40],
    94: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    95: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    96: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    97: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    98: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    99: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    100: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    101: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    102: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    103: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    104: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    105: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    106: [14, 32, 33, 48, 34, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    107: [54],
    108: [48],
    109: [37],
    110: [14, 32, 33, 48, 34, -1, 37, 36, 21, 54, 26, 10, 43, 44, 30],
    111: [44],
    112: [44],
    113: [44],
    114: [44, -1],
    115: [34],
    116: [26],
    117: [14, 32, 33, 48, 34, -1, 30, 37, 21, 54, 26, 10, 43, 44, 36],
    118: [43],
    119: [10],
    120: [21],
    121: [14],
    122: [44],
    123: [32],
    124: [30],
    125: [36],
}
var nonterminal_rules = {
    59: [
        "$_gen5 = list($command_part)",
    ],
    60: [
        "$wf_output_wildcard = :dot :asterisk -> $1",
    ],
    61: [
        "$wf_output_declaration_syntax = $type_e :identifier :equal $e -> WorkflowOutputDeclaration( type=$0, name=$1, expression=$3 )",
    ],
    62: [
        "$output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )",
    ],
    63: [
        "$map = :lbrace $_gen8 :rbrace -> $1",
    ],
    64: [
        "$document = $_gen0 $_gen1 -> Namespace( imports=$0, body=$1 )",
    ],
    65: [
        "$call = :call :fqn $_gen14 $_gen15 -> Call( task=$1, alias=$2, body=$3 )",
    ],
    66: [
        "$sections = $command",
        "$sections = $outputs",
        "$sections = $runtime",
        "$sections = $parameter_meta",
        "$sections = $meta",
    ],
    67: [
        "$wf_output_wildcard_syntax = :fqn $_gen19 -> WorkflowOutputWildcard( fqn=$0, wildcard=$1 )",
    ],
    68: [
        "$_gen6 = list($cmd_param_kv)",
    ],
    69: [
        "$_gen12 = $setter",
        "$_gen12 = :_empty",
    ],
    70: [
        "$_gen19 = $wf_output_wildcard",
        "$_gen19 = :_empty",
    ],
    71: [
        "$workflow_or_task_or_decl = $workflow",
        "$workflow_or_task_or_decl = $task",
        "$workflow_or_task_or_decl = $declaration",
    ],
    72: [
        "$_gen10 = list($meta_kv, :comma)",
    ],
    73: [
        "$call_body = :lbrace $_gen3 $_gen16 :rbrace -> CallBody( declarations=$1, io=$2 )",
    ],
    74: [
        "$wf_outputs = :output :lbrace $_gen18 :rbrace -> WorkflowOutputs( outputs=$2 )",
    ],
    75: [
        "$setter = :equal $e -> $1",
    ],
    76: [
        "$wf_meta = :meta $map -> Meta( map=$1 )",
    ],
    77: [
        "$_gen9 = list($meta_kv)",
    ],
    78: [
        "$while_loop = :while :lparen $e :rparen :lbrace $_gen13 :rbrace -> WhileLoop( expression=$2, body=$5 )",
    ],
    79: [
        "$meta_object = :lbrace $_gen10 :rbrace",
    ],
    80: [
        "$mapping = :identifier :equal $e -> IOMapping( key=$0, value=$2 )",
    ],
    81: [
        "$cmd_param = :cmd_param_start $_gen6 $e :cmd_param_end -> CommandParameter( attributes=$1, expr=$2 )",
    ],
    82: [
        "$meta_array = :lsquare $_gen11 :rsquare",
    ],
    83: [
        "$_gen8 = list($kv)",
    ],
    84: [
        "$task = :task :identifier :lbrace $_gen3 $_gen4 :rbrace -> Task( name=$1, declarations=$3, sections=$4 )",
    ],
    85: [
        "$outputs = :output :lbrace $_gen7 :rbrace -> Outputs( attributes=$2 )",
    ],
    86: [
        "$meta_map = :lbrace $_gen9 :rbrace -> $1",
    ],
    87: [
        "$if_stmt = :if :lparen $e :rparen :lbrace $_gen13 :rbrace -> If( expression=$2, body=$5 )",
    ],
    88: [
        "$_gen20 = list($type_e, :comma)",
    ],
    89: [
        "$_gen2 = $import_namespace",
        "$_gen2 = :_empty",
    ],
    90: [
        "$parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )",
    ],
    91: [
        "$_gen15 = $call_body",
        "$_gen15 = :_empty",
    ],
    92: [
        "$wf_parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )",
    ],
    93: [
        "$_gen1 = list($workflow_or_task_or_decl)",
    ],
    94: [
        "$_gen4 = list($sections)",
    ],
    95: [
        "$_gen3 = list($declaration)",
    ],
    96: [
        "$command_part = :cmd_part",
        "$command_part = $cmd_param",
    ],
    97: [
        "$_gen14 = $alias",
        "$_gen14 = :_empty",
    ],
    98: [
        "$meta_kv = :identifier :colon $meta_value",
    ],
    99: [
        "$_gen21 = list($e, :comma)",
    ],
    100: [
        "$declaration = $type_e :identifier $_gen12 -> Declaration( type=$0, name=$1, expression=$2 )",
    ],
    101: [
        "$cmd_param_kv = :cmd_attr_hint :identifier :equal $e -> CommandParameterAttr( key=$1, value=$3 )",
    ],
    102: [
        "$object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )",
    ],
    103: [
        "$alias = :as :identifier -> $1",
    ],
    104: [
        "$kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )",
    ],
    105: [
        "$_gen18 = list($wf_output)",
    ],
    106: [
        "$_gen0 = list($import)",
    ],
    107: [
        "$_gen13 = list($wf_body_element)",
    ],
    108: [
        "$type_e = :type <=> :lsquare $_gen20 :rsquare -> Type( name=$0, subtype=$2 )",
        "$type_e = :type <=> :qmark -> OptionalType( innerType=$0 )",
        "$type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )",
        "$type_e = :type",
    ],
    109: [
        "$scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen13 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )",
    ],
    110: [
        "$_gen17 = list($mapping, :comma)",
    ],
    111: [
        "$_gen23 = list($map_kv, :comma)",
    ],
    112: [
        "$meta = :meta $meta_map -> Meta( map=$1 )",
    ],
    113: [
        "$import = :import :string $_gen2 -> Import( uri=$1, namespace=$2 )",
    ],
    114: [
        "$map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )",
    ],
    115: [
        "$workflow = :workflow :identifier :lbrace $_gen13 :rbrace -> Workflow( name=$1, body=$3 )",
    ],
    116: [
        "$e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )",
        "$e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )",
        "$e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )",
        "$e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )",
        "$e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )",
        "$e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )",
        "$e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )",
        "$e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )",
        "$e = $e :plus $e -> Add( lhs=$0, rhs=$2 )",
        "$e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )",
        "$e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )",
        "$e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )",
        "$e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )",
        "$e = :not $e -> LogicalNot( expression=$1 )",
        "$e = :plus $e -> UnaryPlus( expression=$1 )",
        "$e = :dash $e -> UnaryNegation( expression=$1 )",
        "$e = :identifier <=> :lparen $_gen21 :rparen -> FunctionCall( name=$0, params=$2 )",
        "$e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )",
        "$e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )",
        "$e = :object :lbrace $_gen22 :rbrace -> ObjectLiteral( map=$2 )",
        "$e = :lsquare $_gen21 :rsquare -> ArrayLiteral( values=$1 )",
        "$e = :lbrace $_gen23 :rbrace -> MapLiteral( map=$1 )",
        "$e = :lparen $_gen21 :rparen -> TupleLiteral( values=$1 )",
        "$e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )",
        "$e = :string",
        "$e = :identifier",
        "$e = :boolean",
        "$e = :integer",
        "$e = :float",
    ],
    117: [
        "$meta_value = :string",
        "$meta_value = :integer",
        "$meta_value = :float",
        "$meta_value = :boolean",
        "$meta_value = :null",
        "$meta_value = $meta_object",
        "$meta_value = $meta_array",
    ],
    118: [
        "$runtime = :runtime $map -> Runtime( map=$1 )",
    ],
    119: [
        "$call_input = :input :colon $_gen17 -> Inputs( map=$2 )",
    ],
    120: [
        "$_gen22 = list($object_kv, :comma)",
    ],
    121: [
        "$import_namespace = :as :identifier -> $1",
    ],
    122: [
        "$_gen11 = list($meta_value, :comma)",
    ],
    123: [
        "$wf_output = $wf_output_declaration_syntax",
        "$wf_output = $wf_output_wildcard_syntax",
    ],
    124: [
        "$wf_body_element = $call",
        "$wf_body_element = $declaration",
        "$wf_body_element = $while_loop",
        "$wf_body_element = $if_stmt",
        "$wf_body_element = $scatter",
        "$wf_body_element = $wf_outputs",
        "$wf_body_element = $wf_parameter_meta",
        "$wf_body_element = $wf_meta",
    ],
    125: [
        "$command = :raw_command :raw_cmd_start $_gen5 :raw_cmd_end -> RawCommand( parts=$2 )",
    ],
    126: [
        "$_gen7 = list($output_kv)",
    ],
    127: [
        "$_gen16 = list($call_input)",
    ],
}
var rules = {
    0: "$_gen0 = list($import)",
    1: "$_gen1 = list($workflow_or_task_or_decl)",
    2: "$document = $_gen0 $_gen1 -> Namespace( imports=$0, body=$1 )",
    3: "$workflow_or_task_or_decl = $workflow",
    4: "$workflow_or_task_or_decl = $task",
    5: "$workflow_or_task_or_decl = $declaration",
    6: "$_gen2 = $import_namespace",
    7: "$_gen2 = :_empty",
    8: "$import = :import :string $_gen2 -> Import( uri=$1, namespace=$2 )",
    9: "$import_namespace = :as :identifier -> $1",
    10: "$_gen3 = list($declaration)",
    11: "$_gen4 = list($sections)",
    12: "$task = :task :identifier :lbrace $_gen3 $_gen4 :rbrace -> Task( name=$1, declarations=$3, sections=$4 )",
    13: "$sections = $command",
    14: "$sections = $outputs",
    15: "$sections = $runtime",
    16: "$sections = $parameter_meta",
    17: "$sections = $meta",
    18: "$_gen5 = list($command_part)",
    19: "$command = :raw_command :raw_cmd_start $_gen5 :raw_cmd_end -> RawCommand( parts=$2 )",
    20: "$command_part = :cmd_part",
    21: "$command_part = $cmd_param",
    22: "$_gen6 = list($cmd_param_kv)",
    23: "$cmd_param = :cmd_param_start $_gen6 $e :cmd_param_end -> CommandParameter( attributes=$1, expr=$2 )",
    24: "$cmd_param_kv = :cmd_attr_hint :identifier :equal $e -> CommandParameterAttr( key=$1, value=$3 )",
    25: "$_gen7 = list($output_kv)",
    26: "$outputs = :output :lbrace $_gen7 :rbrace -> Outputs( attributes=$2 )",
    27: "$output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )",
    28: "$runtime = :runtime $map -> Runtime( map=$1 )",
    29: "$_gen8 = list($kv)",
    30: "$map = :lbrace $_gen8 :rbrace -> $1",
    31: "$kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )",
    32: "$meta = :meta $meta_map -> Meta( map=$1 )",
    33: "$parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )",
    34: "$_gen9 = list($meta_kv)",
    35: "$meta_map = :lbrace $_gen9 :rbrace -> $1",
    36: "$meta_kv = :identifier :colon $meta_value",
    37: "$meta_value = :string",
    38: "$meta_value = :integer",
    39: "$meta_value = :float",
    40: "$meta_value = :boolean",
    41: "$meta_value = :null",
    42: "$meta_value = $meta_object",
    43: "$meta_value = $meta_array",
    44: "$_gen10 = list($meta_kv, :comma)",
    45: "$meta_object = :lbrace $_gen10 :rbrace",
    46: "$_gen11 = list($meta_value, :comma)",
    47: "$meta_array = :lsquare $_gen11 :rsquare",
    48: "$_gen12 = $setter",
    49: "$_gen12 = :_empty",
    50: "$declaration = $type_e :identifier $_gen12 -> Declaration( type=$0, name=$1, expression=$2 )",
    51: "$setter = :equal $e -> $1",
    52: "$map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )",
    53: "$_gen13 = list($wf_body_element)",
    54: "$workflow = :workflow :identifier :lbrace $_gen13 :rbrace -> Workflow( name=$1, body=$3 )",
    55: "$wf_body_element = $call",
    56: "$wf_body_element = $declaration",
    57: "$wf_body_element = $while_loop",
    58: "$wf_body_element = $if_stmt",
    59: "$wf_body_element = $scatter",
    60: "$wf_body_element = $wf_outputs",
    61: "$wf_body_element = $wf_parameter_meta",
    62: "$wf_body_element = $wf_meta",
    63: "$_gen14 = $alias",
    64: "$_gen14 = :_empty",
    65: "$_gen15 = $call_body",
    66: "$_gen15 = :_empty",
    67: "$call = :call :fqn $_gen14 $_gen15 -> Call( task=$1, alias=$2, body=$3 )",
    68: "$_gen16 = list($call_input)",
    69: "$call_body = :lbrace $_gen3 $_gen16 :rbrace -> CallBody( declarations=$1, io=$2 )",
    70: "$_gen17 = list($mapping, :comma)",
    71: "$call_input = :input :colon $_gen17 -> Inputs( map=$2 )",
    72: "$mapping = :identifier :equal $e -> IOMapping( key=$0, value=$2 )",
    73: "$alias = :as :identifier -> $1",
    74: "$_gen18 = list($wf_output)",
    75: "$wf_outputs = :output :lbrace $_gen18 :rbrace -> WorkflowOutputs( outputs=$2 )",
    76: "$wf_output = $wf_output_declaration_syntax",
    77: "$wf_output = $wf_output_wildcard_syntax",
    78: "$wf_output_declaration_syntax = $type_e :identifier :equal $e -> WorkflowOutputDeclaration( type=$0, name=$1, expression=$3 )",
    79: "$_gen19 = $wf_output_wildcard",
    80: "$_gen19 = :_empty",
    81: "$wf_output_wildcard_syntax = :fqn $_gen19 -> WorkflowOutputWildcard( fqn=$0, wildcard=$1 )",
    82: "$wf_output_wildcard = :dot :asterisk -> $1",
    83: "$wf_parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )",
    84: "$wf_meta = :meta $map -> Meta( map=$1 )",
    85: "$while_loop = :while :lparen $e :rparen :lbrace $_gen13 :rbrace -> WhileLoop( expression=$2, body=$5 )",
    86: "$if_stmt = :if :lparen $e :rparen :lbrace $_gen13 :rbrace -> If( expression=$2, body=$5 )",
    87: "$scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen13 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )",
    88: "$object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )",
    89: "$_gen20 = list($type_e, :comma)",
    90: "$type_e = :type <=> :lsquare $_gen20 :rsquare -> Type( name=$0, subtype=$2 )",
    91: "$type_e = :type <=> :qmark -> OptionalType( innerType=$0 )",
    92: "$type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )",
    93: "$type_e = :type",
    94: "$e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )",
    95: "$e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )",
    96: "$e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )",
    97: "$e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )",
    98: "$e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )",
    99: "$e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )",
    100: "$e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )",
    101: "$e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )",
    102: "$e = $e :plus $e -> Add( lhs=$0, rhs=$2 )",
    103: "$e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )",
    104: "$e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )",
    105: "$e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )",
    106: "$e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )",
    107: "$e = :not $e -> LogicalNot( expression=$1 )",
    108: "$e = :plus $e -> UnaryPlus( expression=$1 )",
    109: "$e = :dash $e -> UnaryNegation( expression=$1 )",
    110: "$_gen21 = list($e, :comma)",
    111: "$e = :identifier <=> :lparen $_gen21 :rparen -> FunctionCall( name=$0, params=$2 )",
    112: "$e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )",
    113: "$e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )",
    114: "$_gen22 = list($object_kv, :comma)",
    115: "$e = :object :lbrace $_gen22 :rbrace -> ObjectLiteral( map=$2 )",
    116: "$e = :lsquare $_gen21 :rsquare -> ArrayLiteral( values=$1 )",
    117: "$_gen23 = list($map_kv, :comma)",
    118: "$e = :lbrace $_gen23 :rbrace -> MapLiteral( map=$1 )",
    119: "$e = :lparen $_gen21 :rparen -> TupleLiteral( values=$1 )",
    120: "$e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )",
    121: "$e = :string",
    122: "$e = :identifier",
    123: "$e = :boolean",
    124: "$e = :integer",
    125: "$e = :float",
}
function is_terminal(id){
    return 0 <= id && id <= 58;
}
function parse(tokens, error_formatter, start) {
    if (error_formatter === undefined) {
        error_formatter = new DefaultSyntaxErrorFormatter();
    }
    var ctx = new ParserContext(tokens, error_formatter);
    var tree = parse_document(ctx);
    if (tokens.current() != null) {
        throw new SyntaxError('Finished parsing without consuming all tokens.');
    }
    return tree;
}
function expect(ctx, terminal_id) {
    var current = ctx.tokens.current();
    if (current == null) {
        throw new SyntaxError(ctx.error_formatter.no_more_tokens(ctx.nonterminal, terminals[terminal_id], ctx.tokens.last()));
    }
    if (current.id != terminal_id) {
        throw new SyntaxError(ctx.error_formatter.unexpected_symbol(ctx.nonterminal, current, [terminals[terminal_id]], ctx.rule));
    }
    var next = ctx.tokens.advance();
    if (next && !is_terminal(next.id)) {
        throw new SyntaxError(ctx.error_formatter.invalid_terminal(ctx.nonterminal, next));
    }
    return current;
}
// START definitions for expression parser `e`
var infix_binding_power_e = {
    39: 4000, // $e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )
    18: 5000, // $e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )
    31: 6000, // $e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )
    28: 6000, // $e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )
    9: 7000, // $e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )
    4: 7000, // $e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )
    13: 7000, // $e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )
    2: 7000, // $e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )
    48: 8000, // $e = $e :plus $e -> Add( lhs=$0, rhs=$2 )
    37: 8000, // $e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )
    46: 9000, // $e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )
    29: 9000, // $e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )
    51: 9000, // $e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )
    10: 11000, // $e = :identifier <=> :lparen list($e, :comma) :rparen -> FunctionCall( name=$0, params=$2 )
    26: 12000, // $e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
    15: 13000, // $e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )
}
var prefix_binding_power_e = {
    54: 10000, // $e = :not $e -> LogicalNot( expression=$1 )
    48: 10000, // $e = :plus $e -> UnaryPlus( expression=$1 )
    37: 10000, // $e = :dash $e -> UnaryNegation( expression=$1 )
}
function get_infix_binding_power_e(terminal_id) {
    if (terminal_id in infix_binding_power_e) {
        return infix_binding_power_e[terminal_id];
    } else {
        return 0;
    }
}
function get_prefix_binding_power_e(terminal_id) {
    if (terminal_id in prefix_binding_power_e) {
        return prefix_binding_power_e[terminal_id];
    } else {
        return 0;
    }
}
function parse_e(ctx) {
    return parse_e_internal(ctx, 0);
}
function parse_e_internal(ctx, rbp) {
    left = nud_e(ctx);
    if (left instanceof ParseTree) {
        left.isExpr = true;
        left.isNud = true;
    }
    while (ctx.tokens.current() && rbp < get_infix_binding_power_e(ctx.tokens.current().id)) {
        left = led_e(left, ctx);
    }
    if (left) {
        left.isExpr = true;
    }
    return left;
}
function nud_e(ctx) {
    var tree = new ParseTree(new NonTerminal(116, 'e'));
    var current = ctx.tokens.current();
    ctx.nonterminal = "e";
    if (!current) {
        return tree;
    }
    else if (rule_first[107].indexOf(current.id) != -1) {
        // $e = :not $e -> LogicalNot( expression=$1 )
        ctx.rule = rules[107];
        ast_parameters = {
            'expression': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('LogicalNot', ast_parameters);
        tree.nudMorphemeCount = 2;
        tree.add(expect(ctx, 54));
        tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(54)));
        tree.isPrefix = true;
    }
    else if (rule_first[108].indexOf(current.id) != -1) {
        // $e = :plus $e -> UnaryPlus( expression=$1 )
        ctx.rule = rules[108];
        ast_parameters = {
            'expression': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('UnaryPlus', ast_parameters);
        tree.nudMorphemeCount = 2;
        tree.add(expect(ctx, 48));
        tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(48)));
        tree.isPrefix = true;
    }
    else if (rule_first[109].indexOf(current.id) != -1) {
        // $e = :dash $e -> UnaryNegation( expression=$1 )
        ctx.rule = rules[109];
        ast_parameters = {
            'expression': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('UnaryNegation', ast_parameters);
        tree.nudMorphemeCount = 2;
        tree.add(expect(ctx, 37));
        tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(37)));
        tree.isPrefix = true;
    }
    else if (rule_first[111].indexOf(current.id) != -1) {
        // $e = :identifier <=> :lparen $_gen21 :rparen -> FunctionCall( name=$0, params=$2 )
        ctx.rule = rules[111];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 44));
    }
    else if (rule_first[112].indexOf(current.id) != -1) {
        // $e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
        ctx.rule = rules[112];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 44));
    }
    else if (rule_first[113].indexOf(current.id) != -1) {
        // $e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )
        ctx.rule = rules[113];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 44));
    }
    else if (rule_first[115].indexOf(current.id) != -1) {
        // $e = :object :lbrace $_gen22 :rbrace -> ObjectLiteral( map=$2 )
        ctx.rule = rules[115];
        ast_parameters = {
            'map': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('ObjectLiteral', ast_parameters);
        tree.nudMorphemeCount = 4;
        tree.add(expect(ctx, 34));
        tree.add(expect(ctx, 43));
        tree.add(parse__gen22(ctx));
        tree.add(expect(ctx, 35));
    }
    else if (rule_first[116].indexOf(current.id) != -1) {
        // $e = :lsquare $_gen21 :rsquare -> ArrayLiteral( values=$1 )
        ctx.rule = rules[116];
        ast_parameters = {
            'values': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('ArrayLiteral', ast_parameters);
        tree.nudMorphemeCount = 3;
        tree.add(expect(ctx, 26));
        tree.add(parse__gen21(ctx));
        tree.add(expect(ctx, 41));
    }
    else if (rule_first[118].indexOf(current.id) != -1) {
        // $e = :lbrace $_gen23 :rbrace -> MapLiteral( map=$1 )
        ctx.rule = rules[118];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('MapLiteral', ast_parameters);
        tree.nudMorphemeCount = 3;
        tree.add(expect(ctx, 43));
        tree.add(parse__gen23(ctx));
        tree.add(expect(ctx, 35));
    }
    else if (rule_first[119].indexOf(current.id) != -1) {
        // $e = :lparen $_gen21 :rparen -> TupleLiteral( values=$1 )
        ctx.rule = rules[119];
        ast_parameters = {
            'values': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('TupleLiteral', ast_parameters);
        tree.nudMorphemeCount = 3;
        tree.add(expect(ctx, 10));
        tree.add(parse__gen21(ctx));
        tree.add(expect(ctx, 12));
    }
    else if (rule_first[120].indexOf(current.id) != -1) {
        // $e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )
        ctx.rule = rules[120];
        ast_parameters = {
            'cond': 1,
            'iftrue': 3,
            'iffalse': 5,
        }
        tree.astTransform = new AstTransformNodeCreator('TernaryIf', ast_parameters);
        tree.nudMorphemeCount = 6;
        tree.add(expect(ctx, 21));
        tree.add(parse_e(ctx));
        tree.add(expect(ctx, 5));
        tree.add(parse_e(ctx));
        tree.add(expect(ctx, 49));
        tree.add(parse_e(ctx));
    }
    else if (rule_first[121].indexOf(current.id) != -1) {
        // $e = :string
        ctx.rule = rules[121];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 14));
    }
    else if (rule_first[122].indexOf(current.id) != -1) {
        // $e = :identifier
        ctx.rule = rules[122];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 44));
    }
    else if (rule_first[123].indexOf(current.id) != -1) {
        // $e = :boolean
        ctx.rule = rules[123];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 32));
    }
    else if (rule_first[124].indexOf(current.id) != -1) {
        // $e = :integer
        ctx.rule = rules[124];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 30));
    }
    else if (rule_first[125].indexOf(current.id) != -1) {
        // $e = :float
        ctx.rule = rules[125];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 36));
    }
    return tree;
}
function led_e(left, ctx) {
    var tree = new ParseTree(new NonTerminal(116, 'e'))
    var current = ctx.tokens.current()
    ctx.nonterminal = "e";
    if (current.id == 39) { // :double_pipe
        // $e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )
        ctx.rule = rules[94];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('LogicalOr', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 39)); // :double_pipe
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(39) - modifier));
    }
    if (current.id == 18) { // :double_ampersand
        // $e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )
        ctx.rule = rules[95];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('LogicalAnd', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 18)); // :double_ampersand
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(18) - modifier));
    }
    if (current.id == 31) { // :double_equal
        // $e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )
        ctx.rule = rules[96];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Equals', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 31)); // :double_equal
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(31) - modifier));
    }
    if (current.id == 28) { // :not_equal
        // $e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )
        ctx.rule = rules[97];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('NotEquals', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 28)); // :not_equal
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(28) - modifier));
    }
    if (current.id == 9) { // :lt
        // $e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )
        ctx.rule = rules[98];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('LessThan', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 9)); // :lt
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(9) - modifier));
    }
    if (current.id == 4) { // :lteq
        // $e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )
        ctx.rule = rules[99];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('LessThanOrEqual', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 4)); // :lteq
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(4) - modifier));
    }
    if (current.id == 13) { // :gt
        // $e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )
        ctx.rule = rules[100];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('GreaterThan', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 13)); // :gt
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(13) - modifier));
    }
    if (current.id == 2) { // :gteq
        // $e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )
        ctx.rule = rules[101];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('GreaterThanOrEqual', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 2)); // :gteq
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(2) - modifier));
    }
    if (current.id == 48) { // :plus
        // $e = $e :plus $e -> Add( lhs=$0, rhs=$2 )
        ctx.rule = rules[102];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Add', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 48)); // :plus
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(48) - modifier));
    }
    if (current.id == 37) { // :dash
        // $e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )
        ctx.rule = rules[103];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Subtract', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 37)); // :dash
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(37) - modifier));
    }
    if (current.id == 46) { // :asterisk
        // $e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )
        ctx.rule = rules[104];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Multiply', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 46)); // :asterisk
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(46) - modifier));
    }
    if (current.id == 29) { // :slash
        // $e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )
        ctx.rule = rules[105];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Divide', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 29)); // :slash
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(29) - modifier));
    }
    if (current.id == 51) { // :percent
        // $e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )
        ctx.rule = rules[106];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Remainder', ast_parameters);
        tree.isExprNud = true;
        tree.add(left);
        tree.add(expect(ctx, 51)); // :percent
        modifier = 0;
        tree.isInfix = true;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(51) - modifier));
    }
    if (current.id == 10) { // :lparen
        // $e = :identifier <=> :lparen $_gen21 :rparen -> FunctionCall( name=$0, params=$2 )
        ctx.rule = rules[111];
        ast_parameters = {
            'name': 0,
            'params': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('FunctionCall', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 10)); // :lparen
        tree.add(parse__gen21(ctx));
        tree.add(expect(ctx, 12)); // :rparen
    }
    if (current.id == 26) { // :lsquare
        // $e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
        ctx.rule = rules[112];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('ArrayOrMapLookup', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 26)); // :lsquare
        modifier = 0;
        tree.add(parse_e_internal(ctx, get_infix_binding_power_e(26) - modifier));
        tree.add(expect(ctx, 41)); // :rsquare
    }
    if (current.id == 15) { // :dot
        // $e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )
        ctx.rule = rules[113];
        ast_parameters = {
            'lhs': 0,
            'rhs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('MemberAccess', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 15)); // :dot
        tree.add(expect(ctx, 44)); // :identifier
    }
    return tree;
}
// END definitions for expression parser `e`
// START definitions for expression parser `type_e`
var infix_binding_power_type_e = {
    26: 1000, // $type_e = :type <=> :lsquare list($type_e, :comma) :rsquare -> Type( name=$0, subtype=$2 )
    47: 2000, // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
    48: 3000, // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
}
var prefix_binding_power_type_e = {
}
function get_infix_binding_power_type_e(terminal_id) {
    if (terminal_id in infix_binding_power_type_e) {
        return infix_binding_power_type_e[terminal_id];
    } else {
        return 0;
    }
}
function get_prefix_binding_power_type_e(terminal_id) {
    if (terminal_id in prefix_binding_power_type_e) {
        return prefix_binding_power_type_e[terminal_id];
    } else {
        return 0;
    }
}
function parse_type_e(ctx) {
    return parse_type_e_internal(ctx, 0);
}
function parse_type_e_internal(ctx, rbp) {
    left = nud_type_e(ctx);
    if (left instanceof ParseTree) {
        left.isExpr = true;
        left.isNud = true;
    }
    while (ctx.tokens.current() && rbp < get_infix_binding_power_type_e(ctx.tokens.current().id)) {
        left = led_type_e(left, ctx);
    }
    if (left) {
        left.isExpr = true;
    }
    return left;
}
function nud_type_e(ctx) {
    var tree = new ParseTree(new NonTerminal(108, 'type_e'));
    var current = ctx.tokens.current();
    ctx.nonterminal = "type_e";
    if (!current) {
        return tree;
    }
    if (rule_first[90].indexOf(current.id) != -1) {
        // $type_e = :type <=> :lsquare $_gen20 :rsquare -> Type( name=$0, subtype=$2 )
        ctx.rule = rules[90];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 40));
    }
    else if (rule_first[91].indexOf(current.id) != -1) {
        // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
        ctx.rule = rules[91];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 40));
    }
    else if (rule_first[92].indexOf(current.id) != -1) {
        // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
        ctx.rule = rules[92];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 40));
    }
    else if (rule_first[93].indexOf(current.id) != -1) {
        // $type_e = :type
        ctx.rule = rules[93];
        tree.astTransform = new AstTransformSubstitution(0);
        tree.nudMorphemeCount = 1;
        tree.add(expect(ctx, 40));
    }
    return tree;
}
function led_type_e(left, ctx) {
    var tree = new ParseTree(new NonTerminal(108, 'type_e'))
    var current = ctx.tokens.current()
    ctx.nonterminal = "type_e";
    if (current.id == 26) { // :lsquare
        // $type_e = :type <=> :lsquare $_gen20 :rsquare -> Type( name=$0, subtype=$2 )
        ctx.rule = rules[90];
        ast_parameters = {
            'name': 0,
            'subtype': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Type', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 26)); // :lsquare
        tree.add(parse__gen20(ctx));
        tree.add(expect(ctx, 41)); // :rsquare
    }
    if (current.id == 47) { // :qmark
        // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
        ctx.rule = rules[91];
        ast_parameters = {
            'innerType': 0,
        }
        tree.astTransform = new AstTransformNodeCreator('OptionalType', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 47)); // :qmark
    }
    if (current.id == 48) { // :plus
        // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
        ctx.rule = rules[92];
        ast_parameters = {
            'innerType': 0,
        }
        tree.astTransform = new AstTransformNodeCreator('NonEmptyType', ast_parameters);
        tree.add(left);
        tree.add(expect(ctx, 48)); // :plus
    }
    return tree;
}
// END definitions for expression parser `type_e`
function parse__gen0(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[47][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(106, '_gen0'));
    ctx.nonterminal = "_gen0";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[106].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[106].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[106].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_import(ctx));
        ctx.nonterminal = "_gen0";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen1(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[34][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(93, '_gen1'));
    ctx.nonterminal = "_gen1";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[93].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[93].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[93].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_workflow_or_task_or_decl(ctx));
        ctx.nonterminal = "_gen1";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen10(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[13][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(72, '_gen10'));
    ctx.nonterminal = "_gen10";
    tree.list = true;
    tree.listSeparator = 38;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[72].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[72].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[72].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_meta_kv(ctx));
        ctx.nonterminal = "_gen10";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 38) {
          tree.add(expect(ctx, 38));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen10",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen11(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[63][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(122, '_gen11'));
    ctx.nonterminal = "_gen11";
    tree.list = true;
    tree.listSeparator = 38;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[122].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[122].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[122].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_meta_value(ctx));
        ctx.nonterminal = "_gen11";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 38) {
          tree.add(expect(ctx, 38));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen11",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen13(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[48][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(107, '_gen13'));
    ctx.nonterminal = "_gen13";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[107].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[107].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[107].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_wf_body_element(ctx));
        ctx.nonterminal = "_gen13";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen16(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[68][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(127, '_gen16'));
    ctx.nonterminal = "_gen16";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[127].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[127].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[127].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_call_input(ctx));
        ctx.nonterminal = "_gen16";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen17(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[51][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(110, '_gen17'));
    ctx.nonterminal = "_gen17";
    tree.list = true;
    tree.listSeparator = 38;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[110].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[110].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[110].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_mapping(ctx));
        ctx.nonterminal = "_gen17";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 38) {
          tree.add(expect(ctx, 38));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen17",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen18(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[46][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(105, '_gen18'));
    ctx.nonterminal = "_gen18";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[105].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[105].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[105].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_wf_output(ctx));
        ctx.nonterminal = "_gen18";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen20(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[29][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(88, '_gen20'));
    ctx.nonterminal = "_gen20";
    tree.list = true;
    tree.listSeparator = 38;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[88].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[88].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[88].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_type_e(ctx));
        ctx.nonterminal = "_gen20";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 38) {
          tree.add(expect(ctx, 38));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen20",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen21(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[40][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(99, '_gen21'));
    ctx.nonterminal = "_gen21";
    tree.list = true;
    tree.listSeparator = 38;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[99].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[99].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[99].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_e(ctx));
        ctx.nonterminal = "_gen21";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 38) {
          tree.add(expect(ctx, 38));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen21",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen22(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[61][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(120, '_gen22'));
    ctx.nonterminal = "_gen22";
    tree.list = true;
    tree.listSeparator = 38;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[120].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[120].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[120].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_object_kv(ctx));
        ctx.nonterminal = "_gen22";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 38) {
          tree.add(expect(ctx, 38));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen22",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen23(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[52][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(111, '_gen23'));
    ctx.nonterminal = "_gen23";
    tree.list = true;
    tree.listSeparator = 38;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[111].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[111].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[111].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_map_kv(ctx));
        ctx.nonterminal = "_gen23";
        if ( ctx.tokens.current() != null && ctx.tokens.current().id == 38) {
          tree.add(expect(ctx, 38));
        } else {
          if (minimum > 1) {
              throw new SyntaxError(ctx.error_formatter.missing_list_items(
                  "_gen23",
                  0,
                  0 - minimum + 1,
                  null
              ));
          }
          break;
        }
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen3(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[36][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(95, '_gen3'));
    ctx.nonterminal = "_gen3";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[95].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[95].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[95].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_declaration(ctx));
        ctx.nonterminal = "_gen3";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen4(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[35][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(94, '_gen4'));
    ctx.nonterminal = "_gen4";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[94].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[94].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[94].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_sections(ctx));
        ctx.nonterminal = "_gen4";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen5(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[0][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(59, '_gen5'));
    ctx.nonterminal = "_gen5";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[59].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[59].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[59].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_command_part(ctx));
        ctx.nonterminal = "_gen5";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen6(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[9][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(68, '_gen6'));
    ctx.nonterminal = "_gen6";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[68].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[68].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[68].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_cmd_param_kv(ctx));
        ctx.nonterminal = "_gen6";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen7(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[67][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(126, '_gen7'));
    ctx.nonterminal = "_gen7";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[126].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[126].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[126].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_output_kv(ctx));
        ctx.nonterminal = "_gen7";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen8(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[24][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(83, '_gen8'));
    ctx.nonterminal = "_gen8";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[83].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[83].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[83].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_kv(ctx));
        ctx.nonterminal = "_gen8";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen9(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[18][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(77, '_gen9'));
    ctx.nonterminal = "_gen9";
    tree.list = true;
    tree.listSeparator = -1;
    tree.astTransform = new AstTransformSubstitution(0);
    if ( ctx.tokens.current() != null &&
         nonterminal_follow[77].indexOf(ctx.tokens.current().id) != -1 &&
         nonterminal_first[77].indexOf(ctx.tokens.current().id) == -1 ) {
        return tree;
    }
    if ( ctx.tokens.current() == null) {
        return tree;
    }
    var minimum = 0;
    while ( minimum > 0 ||
            (ctx.tokens.current() != null &&
             nonterminal_first[77].indexOf(ctx.tokens.current().id) != -1)) {
        tree.add(parse_meta_kv(ctx));
        ctx.nonterminal = "_gen9";
        minimum = Math.max(minimum - 1, 0);
    }
    return tree;
}
function parse__gen12(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[10][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(69, '_gen12'));
    ctx.nonterminal = "_gen12";
    if (current != null && nonterminal_follow[69].indexOf(current.id) != -1 && nonterminal_first[69].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 48) { // $_gen12 = $setter
        ctx.rule = rules[48];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_setter(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse__gen14(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[38][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(97, '_gen14'));
    ctx.nonterminal = "_gen14";
    if (current != null && nonterminal_follow[97].indexOf(current.id) != -1 && nonterminal_first[97].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 63) { // $_gen14 = $alias
        ctx.rule = rules[63];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_alias(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse__gen15(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[32][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(91, '_gen15'));
    ctx.nonterminal = "_gen15";
    if (current != null && nonterminal_follow[91].indexOf(current.id) != -1 && nonterminal_first[91].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 65) { // $_gen15 = $call_body
        ctx.rule = rules[65];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_call_body(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse__gen19(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[11][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(70, '_gen19'));
    ctx.nonterminal = "_gen19";
    if (current != null && nonterminal_follow[70].indexOf(current.id) != -1 && nonterminal_first[70].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 79) { // $_gen19 = $wf_output_wildcard
        ctx.rule = rules[79];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_output_wildcard(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse__gen2(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[30][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(89, '_gen2'));
    ctx.nonterminal = "_gen2";
    if (current != null && nonterminal_follow[89].indexOf(current.id) != -1 && nonterminal_first[89].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 6) { // $_gen2 = $import_namespace
        ctx.rule = rules[6];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_import_namespace(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse_alias(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[44][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(103, 'alias'));
    ctx.nonterminal = "alias";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 73) { // $alias = :as :identifier -> $1
        ctx.rule = rules[73];
        tree.astTransform = new AstTransformSubstitution(1);
        t = expect(ctx, 58); // :as
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[103],
        rules[73]
    ));
}
function parse_call(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[6][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(65, 'call'));
    ctx.nonterminal = "call";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 67) { // $call = :call :fqn $_gen14 $_gen15 -> Call( task=$1, alias=$2, body=$3 )
        ctx.rule = rules[67];
        ast_parameters = {
            'task': 1,
            'alias': 2,
            'body': 3,
        }
        tree.astTransform = new AstTransformNodeCreator('Call', ast_parameters);
        t = expect(ctx, 27); // :call
        tree.add(t);
        t = expect(ctx, 19); // :fqn
        tree.add(t);
        subtree = parse__gen14(ctx);
        tree.add(subtree);
        subtree = parse__gen15(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[65],
        rules[67]
    ));
}
function parse_call_body(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[14][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(73, 'call_body'));
    ctx.nonterminal = "call_body";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 69) { // $call_body = :lbrace $_gen3 $_gen16 :rbrace -> CallBody( declarations=$1, io=$2 )
        ctx.rule = rules[69];
        ast_parameters = {
            'declarations': 1,
            'io': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('CallBody', ast_parameters);
        t = expect(ctx, 43); // :lbrace
        tree.add(t);
        subtree = parse__gen3(ctx);
        tree.add(subtree);
        subtree = parse__gen16(ctx);
        tree.add(subtree);
        t = expect(ctx, 35); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[73],
        rules[69]
    ));
}
function parse_call_input(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[60][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(119, 'call_input'));
    ctx.nonterminal = "call_input";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 71) { // $call_input = :input :colon $_gen17 -> Inputs( map=$2 )
        ctx.rule = rules[71];
        ast_parameters = {
            'map': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Inputs', ast_parameters);
        t = expect(ctx, 42); // :input
        tree.add(t);
        t = expect(ctx, 56); // :colon
        tree.add(t);
        subtree = parse__gen17(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[119],
        rules[71]
    ));
}
function parse_cmd_param(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[22][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(81, 'cmd_param'));
    ctx.nonterminal = "cmd_param";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 23) { // $cmd_param = :cmd_param_start $_gen6 $e :cmd_param_end -> CommandParameter( attributes=$1, expr=$2 )
        ctx.rule = rules[23];
        ast_parameters = {
            'attributes': 1,
            'expr': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('CommandParameter', ast_parameters);
        t = expect(ctx, 22); // :cmd_param_start
        tree.add(t);
        subtree = parse__gen6(ctx);
        tree.add(subtree);
        subtree = parse_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 55); // :cmd_param_end
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[81],
        rules[23]
    ));
}
function parse_cmd_param_kv(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[42][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(101, 'cmd_param_kv'));
    ctx.nonterminal = "cmd_param_kv";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 24) { // $cmd_param_kv = :cmd_attr_hint :identifier :equal $e -> CommandParameterAttr( key=$1, value=$3 )
        ctx.rule = rules[24];
        ast_parameters = {
            'key': 1,
            'value': 3,
        }
        tree.astTransform = new AstTransformNodeCreator('CommandParameterAttr', ast_parameters);
        t = expect(ctx, 3); // :cmd_attr_hint
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 16); // :equal
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[101],
        rules[24]
    ));
}
function parse_command(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[66][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(125, 'command'));
    ctx.nonterminal = "command";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 19) { // $command = :raw_command :raw_cmd_start $_gen5 :raw_cmd_end -> RawCommand( parts=$2 )
        ctx.rule = rules[19];
        ast_parameters = {
            'parts': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('RawCommand', ast_parameters);
        t = expect(ctx, 20); // :raw_command
        tree.add(t);
        t = expect(ctx, 57); // :raw_cmd_start
        tree.add(t);
        subtree = parse__gen5(ctx);
        tree.add(subtree);
        t = expect(ctx, 24); // :raw_cmd_end
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[125],
        rules[19]
    ));
}
function parse_command_part(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[37][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(96, 'command_part'));
    ctx.nonterminal = "command_part";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 20) { // $command_part = :cmd_part
        ctx.rule = rules[20];
        tree.astTransform = new AstTransformSubstitution(0);
        t = expect(ctx, 7); // :cmd_part
        tree.add(t);
        return tree;
    }
    else if (rule == 21) { // $command_part = $cmd_param
        ctx.rule = rules[21];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_cmd_param(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[96],
        rules[21]
    ));
}
function parse_declaration(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[41][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(100, 'declaration'));
    ctx.nonterminal = "declaration";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 50) { // $declaration = $type_e :identifier $_gen12 -> Declaration( type=$0, name=$1, expression=$2 )
        ctx.rule = rules[50];
        ast_parameters = {
            'type': 0,
            'name': 1,
            'expression': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Declaration', ast_parameters);
        subtree = parse_type_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        subtree = parse__gen12(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[100],
        rules[50]
    ));
}
function parse_document(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[5][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(64, 'document'));
    ctx.nonterminal = "document";
    if (current != null && nonterminal_follow[64].indexOf(current.id) != -1 && nonterminal_first[64].indexOf(current.id) == -1) {
        return tree;
    }
    if (current == null) {
        return tree;
    }
    if (rule == 2) { // $document = $_gen0 $_gen1 -> Namespace( imports=$0, body=$1 )
        ctx.rule = rules[2];
        ast_parameters = {
            'imports': 0,
            'body': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('Namespace', ast_parameters);
        subtree = parse__gen0(ctx);
        tree.add(subtree);
        subtree = parse__gen1(ctx);
        tree.add(subtree);
        return tree;
    }
    return tree;
}
function parse_if_stmt(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[28][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(87, 'if_stmt'));
    ctx.nonterminal = "if_stmt";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 86) { // $if_stmt = :if :lparen $e :rparen :lbrace $_gen13 :rbrace -> If( expression=$2, body=$5 )
        ctx.rule = rules[86];
        ast_parameters = {
            'expression': 2,
            'body': 5,
        }
        tree.astTransform = new AstTransformNodeCreator('If', ast_parameters);
        t = expect(ctx, 21); // :if
        tree.add(t);
        t = expect(ctx, 10); // :lparen
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 12); // :rparen
        tree.add(t);
        t = expect(ctx, 43); // :lbrace
        tree.add(t);
        subtree = parse__gen13(ctx);
        tree.add(subtree);
        t = expect(ctx, 35); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[87],
        rules[86]
    ));
}
function parse_import(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[54][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(113, 'import'));
    ctx.nonterminal = "import";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 8) { // $import = :import :string $_gen2 -> Import( uri=$1, namespace=$2 )
        ctx.rule = rules[8];
        ast_parameters = {
            'uri': 1,
            'namespace': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Import', ast_parameters);
        t = expect(ctx, 8); // :import
        tree.add(t);
        t = expect(ctx, 14); // :string
        tree.add(t);
        subtree = parse__gen2(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[113],
        rules[8]
    ));
}
function parse_import_namespace(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[62][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(121, 'import_namespace'));
    ctx.nonterminal = "import_namespace";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 9) { // $import_namespace = :as :identifier -> $1
        ctx.rule = rules[9];
        tree.astTransform = new AstTransformSubstitution(1);
        t = expect(ctx, 58); // :as
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[121],
        rules[9]
    ));
}
function parse_kv(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[45][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(104, 'kv'));
    ctx.nonterminal = "kv";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 31) { // $kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )
        ctx.rule = rules[31];
        ast_parameters = {
            'key': 0,
            'value': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('RuntimeAttribute', ast_parameters);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 56); // :colon
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[104],
        rules[31]
    ));
}
function parse_map(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[4][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(63, 'map'));
    ctx.nonterminal = "map";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 30) { // $map = :lbrace $_gen8 :rbrace -> $1
        ctx.rule = rules[30];
        tree.astTransform = new AstTransformSubstitution(1);
        t = expect(ctx, 43); // :lbrace
        tree.add(t);
        subtree = parse__gen8(ctx);
        tree.add(subtree);
        t = expect(ctx, 35); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[63],
        rules[30]
    ));
}
function parse_map_kv(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[55][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(114, 'map_kv'));
    ctx.nonterminal = "map_kv";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 52) { // $map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )
        ctx.rule = rules[52];
        ast_parameters = {
            'key': 0,
            'value': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('MapLiteralKv', ast_parameters);
        subtree = parse_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 56); // :colon
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[114],
        rules[52]
    ));
}
function parse_mapping(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[21][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(80, 'mapping'));
    ctx.nonterminal = "mapping";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 72) { // $mapping = :identifier :equal $e -> IOMapping( key=$0, value=$2 )
        ctx.rule = rules[72];
        ast_parameters = {
            'key': 0,
            'value': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('IOMapping', ast_parameters);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 16); // :equal
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[80],
        rules[72]
    ));
}
function parse_meta(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[53][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(112, 'meta'));
    ctx.nonterminal = "meta";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 32) { // $meta = :meta $meta_map -> Meta( map=$1 )
        ctx.rule = rules[32];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('Meta', ast_parameters);
        t = expect(ctx, 53); // :meta
        tree.add(t);
        subtree = parse_meta_map(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[112],
        rules[32]
    ));
}
function parse_meta_array(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[23][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(82, 'meta_array'));
    ctx.nonterminal = "meta_array";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 47) { // $meta_array = :lsquare $_gen11 :rsquare
        ctx.rule = rules[47];
        tree.astTransform = new AstTransformSubstitution(0);
        t = expect(ctx, 26); // :lsquare
        tree.add(t);
        subtree = parse__gen11(ctx);
        tree.add(subtree);
        t = expect(ctx, 41); // :rsquare
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[82],
        rules[47]
    ));
}
function parse_meta_kv(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[39][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(98, 'meta_kv'));
    ctx.nonterminal = "meta_kv";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 36) { // $meta_kv = :identifier :colon $meta_value
        ctx.rule = rules[36];
        tree.astTransform = new AstTransformSubstitution(0);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 56); // :colon
        tree.add(t);
        subtree = parse_meta_value(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[98],
        rules[36]
    ));
}
function parse_meta_map(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[27][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(86, 'meta_map'));
    ctx.nonterminal = "meta_map";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 35) { // $meta_map = :lbrace $_gen9 :rbrace -> $1
        ctx.rule = rules[35];
        tree.astTransform = new AstTransformSubstitution(1);
        t = expect(ctx, 43); // :lbrace
        tree.add(t);
        subtree = parse__gen9(ctx);
        tree.add(subtree);
        t = expect(ctx, 35); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[86],
        rules[35]
    ));
}
function parse_meta_object(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[20][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(79, 'meta_object'));
    ctx.nonterminal = "meta_object";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 45) { // $meta_object = :lbrace $_gen10 :rbrace
        ctx.rule = rules[45];
        tree.astTransform = new AstTransformSubstitution(0);
        t = expect(ctx, 43); // :lbrace
        tree.add(t);
        subtree = parse__gen10(ctx);
        tree.add(subtree);
        t = expect(ctx, 35); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[79],
        rules[45]
    ));
}
function parse_meta_value(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[58][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(117, 'meta_value'));
    ctx.nonterminal = "meta_value";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 37) { // $meta_value = :string
        ctx.rule = rules[37];
        tree.astTransform = new AstTransformSubstitution(0);
        t = expect(ctx, 14); // :string
        tree.add(t);
        return tree;
    }
    else if (rule == 38) { // $meta_value = :integer
        ctx.rule = rules[38];
        tree.astTransform = new AstTransformSubstitution(0);
        t = expect(ctx, 30); // :integer
        tree.add(t);
        return tree;
    }
    else if (rule == 39) { // $meta_value = :float
        ctx.rule = rules[39];
        tree.astTransform = new AstTransformSubstitution(0);
        t = expect(ctx, 36); // :float
        tree.add(t);
        return tree;
    }
    else if (rule == 40) { // $meta_value = :boolean
        ctx.rule = rules[40];
        tree.astTransform = new AstTransformSubstitution(0);
        t = expect(ctx, 32); // :boolean
        tree.add(t);
        return tree;
    }
    else if (rule == 41) { // $meta_value = :null
        ctx.rule = rules[41];
        tree.astTransform = new AstTransformSubstitution(0);
        t = expect(ctx, 23); // :null
        tree.add(t);
        return tree;
    }
    else if (rule == 42) { // $meta_value = $meta_object
        ctx.rule = rules[42];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_meta_object(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 43) { // $meta_value = $meta_array
        ctx.rule = rules[43];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_meta_array(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[117],
        rules[43]
    ));
}
function parse_object_kv(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[43][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(102, 'object_kv'));
    ctx.nonterminal = "object_kv";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 88) { // $object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )
        ctx.rule = rules[88];
        ast_parameters = {
            'key': 0,
            'value': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('ObjectKV', ast_parameters);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 56); // :colon
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[102],
        rules[88]
    ));
}
function parse_output_kv(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[3][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(62, 'output_kv'));
    ctx.nonterminal = "output_kv";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 27) { // $output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )
        ctx.rule = rules[27];
        ast_parameters = {
            'type': 0,
            'name': 1,
            'expression': 3,
        }
        tree.astTransform = new AstTransformNodeCreator('Output', ast_parameters);
        subtree = parse_type_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 16); // :equal
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[62],
        rules[27]
    ));
}
function parse_outputs(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[26][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(85, 'outputs'));
    ctx.nonterminal = "outputs";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 26) { // $outputs = :output :lbrace $_gen7 :rbrace -> Outputs( attributes=$2 )
        ctx.rule = rules[26];
        ast_parameters = {
            'attributes': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('Outputs', ast_parameters);
        t = expect(ctx, 17); // :output
        tree.add(t);
        t = expect(ctx, 43); // :lbrace
        tree.add(t);
        subtree = parse__gen7(ctx);
        tree.add(subtree);
        t = expect(ctx, 35); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[85],
        rules[26]
    ));
}
function parse_parameter_meta(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[31][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(90, 'parameter_meta'));
    ctx.nonterminal = "parameter_meta";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 33) { // $parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )
        ctx.rule = rules[33];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('ParameterMeta', ast_parameters);
        t = expect(ctx, 45); // :parameter_meta
        tree.add(t);
        subtree = parse_meta_map(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[90],
        rules[33]
    ));
}
function parse_runtime(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[59][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(118, 'runtime'));
    ctx.nonterminal = "runtime";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 28) { // $runtime = :runtime $map -> Runtime( map=$1 )
        ctx.rule = rules[28];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('Runtime', ast_parameters);
        t = expect(ctx, 25); // :runtime
        tree.add(t);
        subtree = parse_map(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[118],
        rules[28]
    ));
}
function parse_scatter(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[50][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(109, 'scatter'));
    ctx.nonterminal = "scatter";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 87) { // $scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen13 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )
        ctx.rule = rules[87];
        ast_parameters = {
            'item': 2,
            'collection': 4,
            'body': 7,
        }
        tree.astTransform = new AstTransformNodeCreator('Scatter', ast_parameters);
        t = expect(ctx, 1); // :scatter
        tree.add(t);
        t = expect(ctx, 10); // :lparen
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 50); // :in
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 12); // :rparen
        tree.add(t);
        t = expect(ctx, 43); // :lbrace
        tree.add(t);
        subtree = parse__gen13(ctx);
        tree.add(subtree);
        t = expect(ctx, 35); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[109],
        rules[87]
    ));
}
function parse_sections(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[7][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(66, 'sections'));
    ctx.nonterminal = "sections";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 13) { // $sections = $command
        ctx.rule = rules[13];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_command(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 14) { // $sections = $outputs
        ctx.rule = rules[14];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_outputs(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 15) { // $sections = $runtime
        ctx.rule = rules[15];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_runtime(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 16) { // $sections = $parameter_meta
        ctx.rule = rules[16];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_parameter_meta(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 17) { // $sections = $meta
        ctx.rule = rules[17];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_meta(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[66],
        rules[17]
    ));
}
function parse_setter(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[16][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(75, 'setter'));
    ctx.nonterminal = "setter";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 51) { // $setter = :equal $e -> $1
        ctx.rule = rules[51];
        tree.astTransform = new AstTransformSubstitution(1);
        t = expect(ctx, 16); // :equal
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[75],
        rules[51]
    ));
}
function parse_task(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[25][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(84, 'task'));
    ctx.nonterminal = "task";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 12) { // $task = :task :identifier :lbrace $_gen3 $_gen4 :rbrace -> Task( name=$1, declarations=$3, sections=$4 )
        ctx.rule = rules[12];
        ast_parameters = {
            'name': 1,
            'declarations': 3,
            'sections': 4,
        }
        tree.astTransform = new AstTransformNodeCreator('Task', ast_parameters);
        t = expect(ctx, 11); // :task
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 43); // :lbrace
        tree.add(t);
        subtree = parse__gen3(ctx);
        tree.add(subtree);
        subtree = parse__gen4(ctx);
        tree.add(subtree);
        t = expect(ctx, 35); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[84],
        rules[12]
    ));
}
function parse_wf_body_element(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[65][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(124, 'wf_body_element'));
    ctx.nonterminal = "wf_body_element";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 55) { // $wf_body_element = $call
        ctx.rule = rules[55];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_call(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 56) { // $wf_body_element = $declaration
        ctx.rule = rules[56];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_declaration(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 57) { // $wf_body_element = $while_loop
        ctx.rule = rules[57];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_while_loop(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 58) { // $wf_body_element = $if_stmt
        ctx.rule = rules[58];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_if_stmt(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 59) { // $wf_body_element = $scatter
        ctx.rule = rules[59];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_scatter(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 60) { // $wf_body_element = $wf_outputs
        ctx.rule = rules[60];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_outputs(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 61) { // $wf_body_element = $wf_parameter_meta
        ctx.rule = rules[61];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_parameter_meta(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 62) { // $wf_body_element = $wf_meta
        ctx.rule = rules[62];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_meta(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[124],
        rules[62]
    ));
}
function parse_wf_meta(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[17][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(76, 'wf_meta'));
    ctx.nonterminal = "wf_meta";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 84) { // $wf_meta = :meta $map -> Meta( map=$1 )
        ctx.rule = rules[84];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('Meta', ast_parameters);
        t = expect(ctx, 53); // :meta
        tree.add(t);
        subtree = parse_map(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[76],
        rules[84]
    ));
}
function parse_wf_output(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[64][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(123, 'wf_output'));
    ctx.nonterminal = "wf_output";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 76) { // $wf_output = $wf_output_declaration_syntax
        ctx.rule = rules[76];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_output_declaration_syntax(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 77) { // $wf_output = $wf_output_wildcard_syntax
        ctx.rule = rules[77];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_wf_output_wildcard_syntax(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[123],
        rules[77]
    ));
}
function parse_wf_output_declaration_syntax(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[2][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(61, 'wf_output_declaration_syntax'));
    ctx.nonterminal = "wf_output_declaration_syntax";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 78) { // $wf_output_declaration_syntax = $type_e :identifier :equal $e -> WorkflowOutputDeclaration( type=$0, name=$1, expression=$3 )
        ctx.rule = rules[78];
        ast_parameters = {
            'type': 0,
            'name': 1,
            'expression': 3,
        }
        tree.astTransform = new AstTransformNodeCreator('WorkflowOutputDeclaration', ast_parameters);
        subtree = parse_type_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 16); // :equal
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[61],
        rules[78]
    ));
}
function parse_wf_output_wildcard(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[1][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(60, 'wf_output_wildcard'));
    ctx.nonterminal = "wf_output_wildcard";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 82) { // $wf_output_wildcard = :dot :asterisk -> $1
        ctx.rule = rules[82];
        tree.astTransform = new AstTransformSubstitution(1);
        t = expect(ctx, 15); // :dot
        tree.add(t);
        t = expect(ctx, 46); // :asterisk
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[60],
        rules[82]
    ));
}
function parse_wf_output_wildcard_syntax(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[8][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(67, 'wf_output_wildcard_syntax'));
    ctx.nonterminal = "wf_output_wildcard_syntax";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 81) { // $wf_output_wildcard_syntax = :fqn $_gen19 -> WorkflowOutputWildcard( fqn=$0, wildcard=$1 )
        ctx.rule = rules[81];
        ast_parameters = {
            'fqn': 0,
            'wildcard': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('WorkflowOutputWildcard', ast_parameters);
        t = expect(ctx, 19); // :fqn
        tree.add(t);
        subtree = parse__gen19(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[67],
        rules[81]
    ));
}
function parse_wf_outputs(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[15][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(74, 'wf_outputs'));
    ctx.nonterminal = "wf_outputs";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 75) { // $wf_outputs = :output :lbrace $_gen18 :rbrace -> WorkflowOutputs( outputs=$2 )
        ctx.rule = rules[75];
        ast_parameters = {
            'outputs': 2,
        }
        tree.astTransform = new AstTransformNodeCreator('WorkflowOutputs', ast_parameters);
        t = expect(ctx, 17); // :output
        tree.add(t);
        t = expect(ctx, 43); // :lbrace
        tree.add(t);
        subtree = parse__gen18(ctx);
        tree.add(subtree);
        t = expect(ctx, 35); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[74],
        rules[75]
    ));
}
function parse_wf_parameter_meta(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[33][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(92, 'wf_parameter_meta'));
    ctx.nonterminal = "wf_parameter_meta";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 83) { // $wf_parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )
        ctx.rule = rules[83];
        ast_parameters = {
            'map': 1,
        }
        tree.astTransform = new AstTransformNodeCreator('ParameterMeta', ast_parameters);
        t = expect(ctx, 45); // :parameter_meta
        tree.add(t);
        subtree = parse_map(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[92],
        rules[83]
    ));
}
function parse_while_loop(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[19][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(78, 'while_loop'));
    ctx.nonterminal = "while_loop";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 85) { // $while_loop = :while :lparen $e :rparen :lbrace $_gen13 :rbrace -> WhileLoop( expression=$2, body=$5 )
        ctx.rule = rules[85];
        ast_parameters = {
            'expression': 2,
            'body': 5,
        }
        tree.astTransform = new AstTransformNodeCreator('WhileLoop', ast_parameters);
        t = expect(ctx, 0); // :while
        tree.add(t);
        t = expect(ctx, 10); // :lparen
        tree.add(t);
        subtree = parse_e(ctx);
        tree.add(subtree);
        t = expect(ctx, 12); // :rparen
        tree.add(t);
        t = expect(ctx, 43); // :lbrace
        tree.add(t);
        subtree = parse__gen13(ctx);
        tree.add(subtree);
        t = expect(ctx, 35); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[78],
        rules[85]
    ));
}
function parse_workflow(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[56][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(115, 'workflow'));
    ctx.nonterminal = "workflow";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 54) { // $workflow = :workflow :identifier :lbrace $_gen13 :rbrace -> Workflow( name=$1, body=$3 )
        ctx.rule = rules[54];
        ast_parameters = {
            'name': 1,
            'body': 3,
        }
        tree.astTransform = new AstTransformNodeCreator('Workflow', ast_parameters);
        t = expect(ctx, 52); // :workflow
        tree.add(t);
        t = expect(ctx, 44); // :identifier
        tree.add(t);
        t = expect(ctx, 43); // :lbrace
        tree.add(t);
        subtree = parse__gen13(ctx);
        tree.add(subtree);
        t = expect(ctx, 35); // :rbrace
        tree.add(t);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[115],
        rules[54]
    ));
}
function parse_workflow_or_task_or_decl(ctx) {
    var current = ctx.tokens.current();
    var rule = current != null ? table[12][current.id] : -1;
    var tree = new ParseTree(new NonTerminal(71, 'workflow_or_task_or_decl'));
    ctx.nonterminal = "workflow_or_task_or_decl";
    if (current == null) {
        throw new SyntaxError('Error: unexpected end of file');
    }
    if (rule == 3) { // $workflow_or_task_or_decl = $workflow
        ctx.rule = rules[3];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_workflow(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 4) { // $workflow_or_task_or_decl = $task
        ctx.rule = rules[4];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_task(ctx);
        tree.add(subtree);
        return tree;
    }
    else if (rule == 5) { // $workflow_or_task_or_decl = $declaration
        ctx.rule = rules[5];
        tree.astTransform = new AstTransformSubstitution(0);
        subtree = parse_declaration(ctx);
        tree.add(subtree);
        return tree;
    }
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
        ctx.nonterminal,
        ctx.tokens.current(),
        nonterminal_first[71],
        rules[5]
    ));
}
// Section: Lexer
// START USER CODE
function init() {
    return {wf_or_task: null};
}
function workflow(ctx, terminal, source_string, line, col) {
    ctx.user_context.wf_or_task = "workflow";
    default_action(ctx, terminal, source_string, line, col);
}
function task(ctx, terminal, source_string, line, col) {
    ctx.user_context.wf_or_task = "task";
    default_action(ctx, terminal, source_string, line, col);
}
function output(ctx, terminal, source_string, line, col) {
    const user_ctx = ctx.user_context;
    if (user_ctx.wf_or_task != null && user_ctx.wf_or_task === "workflow") {
        ctx.mode_stack.push("wf_output");
    }
    default_action(ctx, terminal, source_string, line, col);
}
function wdl_unescape(ctx, terminal, source_string, line, col) {
    var strip_slashes = function(str) {
       return str
           .replace(/\\(.?)/g, function (s, n1) {
             var escapes = {
                 '\\': '\\',
                 '0' : '\u0000',
                 ''  : '',
                 'n' : '\n',
                 'r' : '\r',
                 'b' : '\b',
                 't' : '\t',
                 'f' : '\f',
                 'a' : '\a',
                 'v' : '\v'};
             var symbol = escapes[n1];
             if (symbol !== undefined) {
                 return symbol;
             }
             return n1;
           });
    }
    var repl_str = strip_slashes(source_string.substring(1, source_string.length - 1));
    default_action(ctx, terminal, repl_str, line, col);
}
// END USER CODE
function emit(ctx, terminal, source_string, line, col) {
    ctx.tokens.push(new Terminal(terminals[terminal], terminal, source_string, ctx.resource, line, col))
}
function default_action(ctx, terminal, source_string, line, col) {
    emit(ctx, terminal, source_string, line, col)
}
function post_filter(tokens) {
    return tokens
}
function destroy(context) {
    return 0;
}
var regex = {
    'default': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("/\\*(.*?)\\*/", "m"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("#.*"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("task(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'task',
                  group: 0,
                  function: task,
              },
          ]
      },
      {
          regex: new RegExp("(call)\\s+"),
          outputs: [
              {
                  terminal: 'call',
                  group: 1,
                  function: null,
              },
              {
                  stack_push: 'task_fqn',
              },
          ]
      },
      {
          regex: new RegExp("workflow(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'workflow',
                  group: 0,
                  function: workflow,
              },
          ]
      },
      {
          regex: new RegExp("import(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'import',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("input(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'input',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("output(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'output',
                  group: 0,
                  function: output,
              },
          ]
      },
      {
          regex: new RegExp("as(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'as',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("if(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'if',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("then(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'then',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("else(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'else',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("while(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'while',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("runtime(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'runtime',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("scatter(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'scatter',
                  group: 0,
                  function: null,
              },
              {
                  stack_push: 'scatter',
              },
          ]
      },
      {
          regex: new RegExp("command\\s*(?=<<<)"),
          outputs: [
              {
                  terminal: 'raw_command',
                  group: 0,
                  function: null,
              },
              {
                  stack_push: 'raw_command2',
              },
          ]
      },
      {
          regex: new RegExp("command\\s*(?=\\{)"),
          outputs: [
              {
                  terminal: 'raw_command',
                  group: 0,
                  function: null,
              },
              {
                  stack_push: 'raw_command',
              },
          ]
      },
      {
          regex: new RegExp("parameter_meta(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'parameter_meta',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("meta(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'meta',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(true|false)(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'boolean',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(object)\\s*(\\{)"),
          outputs: [
              {
                  terminal: 'object',
                  group: 0,
                  function: null,
              },
              {
                  terminal: 'lbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'type',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
          outputs: [
              {
                  terminal: 'identifier',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("null"),
          outputs: [
              {
                  terminal: 'null',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\\"([^\\\\\\\"\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*\\\\?\""),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp("'([^\\\\\\'\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*'"),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp(":"),
          outputs: [
              {
                  terminal: 'colon',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(","),
          outputs: [
              {
                  terminal: 'comma',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("=="),
          outputs: [
              {
                  terminal: 'double_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\|\\|"),
          outputs: [
              {
                  terminal: 'double_pipe',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\&\\&"),
          outputs: [
              {
                  terminal: 'double_ampersand',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!="),
          outputs: [
              {
                  terminal: 'not_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("="),
          outputs: [
              {
                  terminal: 'equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\{"),
          outputs: [
              {
                  terminal: 'lbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\}"),
          outputs: [
              {
                  terminal: 'rbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\("),
          outputs: [
              {
                  terminal: 'lparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\)"),
          outputs: [
              {
                  terminal: 'rparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\["),
          outputs: [
              {
                  terminal: 'lsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\]"),
          outputs: [
              {
                  terminal: 'rsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\+"),
          outputs: [
              {
                  terminal: 'plus',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("-"),
          outputs: [
              {
                  terminal: 'dash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("/"),
          outputs: [
              {
                  terminal: 'slash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("%"),
          outputs: [
              {
                  terminal: 'percent',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<="),
          outputs: [
              {
                  terminal: 'lteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<"),
          outputs: [
              {
                  terminal: 'lt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">="),
          outputs: [
              {
                  terminal: 'gteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">"),
          outputs: [
              {
                  terminal: 'gt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!"),
          outputs: [
              {
                  terminal: 'not',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\?"),
          outputs: [
              {
                  terminal: 'qmark',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("-?[0-9]+\\.[0-9]+"),
          outputs: [
              {
                  terminal: 'float',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[0-9]+"),
          outputs: [
              {
                  terminal: 'integer',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'wf_output': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("#.*"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'type',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
              {
                  stack_push: 'wf_output_declaration',
              },
          ]
      },
      {
          regex: new RegExp("\\{"),
          outputs: [
              {
                  terminal: 'lbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\}"),
          outputs: [
              {
                  terminal: 'rbrace',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp(","),
          outputs: [
              {
                  terminal: 'comma',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*(\\.[a-zA-Z]([a-zA-Z0-9_])*)*"),
          outputs: [
              {
                  terminal: 'fqn',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'wf_output_declaration': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("#.*"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("\\}"),
          outputs: [
              {
                  terminal: 'rbrace',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp("\\["),
          outputs: [
              {
                  terminal: 'lsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\]"),
          outputs: [
              {
                  terminal: 'rsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\+"),
          outputs: [
              {
                  terminal: 'plus',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[0-9]+"),
          outputs: [
              {
                  terminal: 'integer',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(true|false)(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'boolean',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("if"),
          outputs: [
              {
                  terminal: 'if',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("else"),
          outputs: [
              {
                  terminal: 'else',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("then"),
          outputs: [
              {
                  terminal: 'then',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'type',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
          outputs: [
              {
                  terminal: 'identifier',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(":"),
          outputs: [
              {
                  terminal: 'colon',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(","),
          outputs: [
              {
                  terminal: 'comma',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("=="),
          outputs: [
              {
                  terminal: 'double_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("="),
          outputs: [
              {
                  terminal: 'equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\|\\|"),
          outputs: [
              {
                  terminal: 'double_pipe',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\&\\&"),
          outputs: [
              {
                  terminal: 'double_ampersand',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!="),
          outputs: [
              {
                  terminal: 'not_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("="),
          outputs: [
              {
                  terminal: 'equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\{"),
          outputs: [
              {
                  terminal: 'lbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\("),
          outputs: [
              {
                  terminal: 'lparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\)"),
          outputs: [
              {
                  terminal: 'rparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\["),
          outputs: [
              {
                  terminal: 'lsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\]"),
          outputs: [
              {
                  terminal: 'rsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\+"),
          outputs: [
              {
                  terminal: 'plus',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("-"),
          outputs: [
              {
                  terminal: 'dash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("/"),
          outputs: [
              {
                  terminal: 'slash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("%"),
          outputs: [
              {
                  terminal: 'percent',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<="),
          outputs: [
              {
                  terminal: 'lteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<"),
          outputs: [
              {
                  terminal: 'lt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">="),
          outputs: [
              {
                  terminal: 'gteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">"),
          outputs: [
              {
                  terminal: 'gt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!"),
          outputs: [
              {
                  terminal: 'not',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\?"),
          outputs: [
              {
                  terminal: 'qmark',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\\"([^\\\\\\\"\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*\\\\?\""),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp("'([^\\\\\\'\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*'"),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp("-?[0-9]+\\.[0-9]+"),
          outputs: [
              {
                  terminal: 'float',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[0-9]+"),
          outputs: [
              {
                  terminal: 'integer',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'task_fqn': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*(\\.[a-zA-Z]([a-zA-Z0-9_])*)*"),
          outputs: [
              {
                  terminal: 'fqn',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
    ],
    'scatter': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("\\("),
          outputs: [
              {
                  terminal: 'lparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("in(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'in',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
          outputs: [
              {
                  terminal: 'identifier',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'raw_command': [
      {
          regex: new RegExp("\\{"),
          outputs: [
              {
                  terminal: 'raw_cmd_start',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\}"),
          outputs: [
              {
                  terminal: 'raw_cmd_end',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp("\\$\\{"),
          outputs: [
              {
                  terminal: 'cmd_param_start',
                  group: 0,
                  function: null,
              },
              {
                  stack_push: 'cmd_param',
              },
          ]
      },
      {
          regex: new RegExp("([\\s\\S]*?)(?=\\$\\{|\\})", "m"),
          outputs: [
              {
                  terminal: 'cmd_part',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'raw_command2': [
      {
          regex: new RegExp("<<<"),
          outputs: [
              {
                  terminal: 'raw_cmd_start',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">>>"),
          outputs: [
              {
                  terminal: 'raw_cmd_end',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp("\\$\\{"),
          outputs: [
              {
                  terminal: 'cmd_param_start',
                  group: 0,
                  function: null,
              },
              {
                  stack_push: 'cmd_param',
              },
          ]
      },
      {
          regex: new RegExp("([\\s\\S]*?)(?=\\$\\{|>>>)", "m"),
          outputs: [
              {
                  terminal: 'cmd_part',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
    'cmd_param': [
      {
          regex: new RegExp("\\s+"),
          outputs: [
          ]
      },
      {
          regex: new RegExp("\\}"),
          outputs: [
              {
                  terminal: 'cmd_param_end',
                  group: 0,
                  function: null,
              },
              {
                  action: 'pop',
              },
          ]
      },
      {
          regex: new RegExp("\\["),
          outputs: [
              {
                  terminal: 'lsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\]"),
          outputs: [
              {
                  terminal: 'rsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("="),
          outputs: [
              {
                  terminal: 'equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\+"),
          outputs: [
              {
                  terminal: 'plus',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[0-9]+"),
          outputs: [
              {
                  terminal: 'integer',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("if"),
          outputs: [
              {
                  terminal: 'if',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("else"),
          outputs: [
              {
                  terminal: 'else',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("then"),
          outputs: [
              {
                  terminal: 'then',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*(?=\\s*=)"),
          outputs: [
              {
                  terminal: 'cmd_attr_hint',
                  group: null,
                  function: null,
              },
              {
                  terminal: 'identifier',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(true|false)(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'boolean',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
          outputs: [
              {
                  terminal: 'type',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
          outputs: [
              {
                  terminal: 'identifier',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(":"),
          outputs: [
              {
                  terminal: 'colon',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(","),
          outputs: [
              {
                  terminal: 'comma',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("=="),
          outputs: [
              {
                  terminal: 'double_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\|\\|"),
          outputs: [
              {
                  terminal: 'double_pipe',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\&\\&"),
          outputs: [
              {
                  terminal: 'double_ampersand',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!="),
          outputs: [
              {
                  terminal: 'not_equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("="),
          outputs: [
              {
                  terminal: 'equal',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\."),
          outputs: [
              {
                  terminal: 'dot',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\{"),
          outputs: [
              {
                  terminal: 'lbrace',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\("),
          outputs: [
              {
                  terminal: 'lparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\)"),
          outputs: [
              {
                  terminal: 'rparen',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\["),
          outputs: [
              {
                  terminal: 'lsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\]"),
          outputs: [
              {
                  terminal: 'rsquare',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\+"),
          outputs: [
              {
                  terminal: 'plus',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\*"),
          outputs: [
              {
                  terminal: 'asterisk',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("-"),
          outputs: [
              {
                  terminal: 'dash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("/"),
          outputs: [
              {
                  terminal: 'slash',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("%"),
          outputs: [
              {
                  terminal: 'percent',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<="),
          outputs: [
              {
                  terminal: 'lteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("<"),
          outputs: [
              {
                  terminal: 'lt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">="),
          outputs: [
              {
                  terminal: 'gteq',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp(">"),
          outputs: [
              {
                  terminal: 'gt',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("!"),
          outputs: [
              {
                  terminal: 'not',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("\\\"([^\\\\\\\"\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*\\\\?\""),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp("'([^\\\\\\'\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*'"),
          outputs: [
              {
                  terminal: 'string',
                  group: 0,
                  function: wdl_unescape,
              },
          ]
      },
      {
          regex: new RegExp("-?[0-9]+\\.[0-9]+"),
          outputs: [
              {
                  terminal: 'float',
                  group: 0,
                  function: null,
              },
          ]
      },
      {
          regex: new RegExp("[0-9]+"),
          outputs: [
              {
                  terminal: 'integer',
                  group: 0,
                  function: null,
              },
          ]
      },
    ],
}
function advance_line_col(string, length, line, col) {
    for (var i = 0; i < length; i++) {
        if (string[i] == '\n') {
            line += 1;
            col = 1;
        } else {
            col += 1;
        }
    }
    return {line: line, col: col}
}
function advance_string(ctx, string) {
    lc = advance_line_col(string, string.length, ctx.line, ctx.col)
    ctx.line = lc.line
    ctx.col = lc.col
    ctx.string = ctx.string.substring(string.length)
}
function _unrecognized_token(string, line, col) {
    var lines = string.split('\n')
    var bad_line = lines[line-1]
    var message = 'Unrecognized token on line {0}, column {1}:\n\n{2}\n{3}'.format(
        line, col, bad_line, Array(col).join(' ') + '^'
    )
    throw new SyntaxError(message)
}
function _next(ctx) {
    var tokens = []
    var mode = ctx.mode_stack[ctx.mode_stack.length - 1]
    for (var i = 0; i < regex[mode].length; i++) {
        match = regex[mode][i].regex.exec(ctx.string);
        if (match != null && match.index == 0) {
            for (var j = 0; j < regex[mode][i].outputs.length; j++) {
                var terminal = regex[mode][i].outputs[j].terminal;
                var group = regex[mode][i].outputs[j].group;
                var func = regex[mode][i].outputs[j].function;
                var stack_push = regex[mode][i].outputs[j].stack_push;
                var action = regex[mode][i].outputs[j].action;
                if (stack_push !== undefined) {
                    ctx.mode_stack.push(stack_push)
                } else if (action !== undefined) {
                    if (action == 'pop') {
                        ctx.mode_stack.pop()
                    }
                } else {
                    func = (func == null) ? default_action : func;
                    var source_string = group != null ? match[group] : ""
                    // Ugh!  JavaScript why you no have regex group indexes?!
                    var group_line = ctx.line
                    var group_col = ctx.col
                    try {
                        var mult_regex = new MultiRegExp(regex[mode][i].regex.source);
                        var mult_groups = mult_regex.exec(ctx.string)
                        if (group != null && group > 0) {
                            var lc = advance_line_col(match[0], mult_groups[group-1].index, ctx.line, ctx.col)
                            group_line = lc.line
                            group_col = lc.col
                        }
                    } catch(err) {}
                    // ^ Literally the worst thing ever
                    func(ctx, terminal, source_string, group_line, group_col)
                }
            }
            advance_string(ctx, match[0])
            return true
        }
    }
    return false
}
function lex(string, resource) {
    ctx = {
        string: string,
        resource: resource,
        user_context: init(),
        mode_stack: ['default'],
        tokens: [],
        line: 1,
        col: 1
    }
    string_copy = string
    parsed_tokens = []
    while (ctx.string.length) {
        matched = _next(ctx)
        if (matched == false) {
            _unrecognized_token(string_copy, ctx.line, ctx.col)
        }
    }
    destroy(ctx.user_context)
    filtered = post_filter(ctx.tokens)
    return new TokenStream(filtered)
}
// Section: Main
// Section: Exports
module.exports = {
  lex: lex,
  parse: parse,
  terminals: terminals,
  parse_tree_string: parse_tree_string,
  ast_string: ast_string
}
